{L, $$, $} = require \./utils/dom
{Thread} = require \./parser
{onready} = require \./utils/features
{truncate} = require \./utils/string
{get, set, sset, sget} = require \./utils/storage
board-template = require \templates/board
catalog-template = require \templates/catalog
unf = require \./unfortunate

page <-! unf.lift {style: require \style/c4} .then

console.time "initial render"

board
  &title    = page.title
  &subtitle = page.subtitle
  &nav      = page.oldDoc.querySelector \#boardNavDesktop  .innerHTML
  &banner   = page.banner
  &message  = page.message
  &sfw = page.sfw

  &type = if &sfw then \sfw else \nsfw
  &favicon = board.favicons[&type]

  # for post deletion
  &password = get \password or Math.random!toString!substr -8

document.body
  &id = board.name
  &className = "#{board.type} \
               #{if board.isThread then \threadpage else \boardpage}"

if board.is-catalog
  catalog = board.catalog = page.data

  order = get \catalog-order or \date
  console.time "generate new HTML body"
  body-html = catalog-template catalog, {order}
  console.timeEnd "generate new HTML body"

  console.time "parse new body HTML"
  document.body.innerHTML = body-html
  console.timeEnd "parse new body HTML"

  require \./catalog
else
  # XXX this is awkward, change unf's api pls
  if board.isThread
    board.thread = new Thread page.data
    board.threads = [board.thread]
  else
    board.threads = for t of page.data
      new Thread t

  # global lookup post by hash
  # XXX cross-board still conflicts
  board.posts = {}
  for board.threads
    for &posts
      board.posts[&no] = &

  # XXX used in features, really want IDB/minimongo/'real man's db'
  board.threads-by-id = {}
  for board.threads
    board.threads-by-id[&op.no] = &


  console.time "generate new HTML body"
  body-html = board-template board
  console.timeEnd "generate new HTML body"

  console.time "parse new body HTML"
  document.body.innerHTML = body-html
  console.timeEnd "parse new body HTML"

console.log board

console.time "prerender handlers"
document.dispatchEvent new CustomEvent do
  \c4-prerender
  detail: {body: document.body}
console.timeEnd "prerender handlers"

if board.isBoard
  console.time "highlight current page"
  href = if board.page is 1 then board.url else board.page
  document.body.querySelector "\#pages a[href=\"#href\"]"
    .id = \current
  console.timeEnd "highlight current page"

function text
  L \div |>
    &innerHTML = it
    &textContent

console.time "set new page title"
document.title =
  if board.isThread
    board.thread.op |>
      "#{truncate do
           &sub or text &com or &filename or &time.relative-date!}
       \ - /#{board.name}/"
  else
    board.title
console.timeEnd "set new page title"

console.time "set correct favicon"
document.head.append with L \link
  &id   = \favicon
  &rel  = \icon
  &type = \image/x-icon # required for chrome, I guess
  &href = board.favicon.src
console.timeEnd "set correct favicon"

console.timeEnd "initial render"

# rescroll to target element if this page hasn't been scrolled before
# this retains the browser's natural scroll position memory
# while still scrolling to the new hash target's position
# the first time the page loads (or if window hasn't been scrolled)
if window.location.hash and not sget document.URL
  window.location.hash = window.location.hash
  window.addEventListener \scroll function registerPage
    sset {+(document.URL)}
    window.removeEventListener \scroll registerPage

# cache current thread hash (which is updated by updater)
version = c4_COMPILATION_VERSION
if board.is-thread
  window.addEventListener \unload !->
    sset "cache-#{board.thread-no}" {version, board.thread}

console.time "onready handlers"
document.dispatchEvent new CustomEvent do
  \c4-ready
  detail: {board.threads, el: $ \threads}
console.timeEnd "onready handlers"
