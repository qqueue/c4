{L, $$, $} = require \./utils/dom
parser = require \./parser
{onready} = require \./utils/features
{truncate} = require \./utils/string
{get, set, sset, sget} = require \./utils/storage
board-template = require \templates/board

# pre-create new DOM
html = L \html
  &appendChild with head = L \head
    &appendChild L \title
    &appendChild with L \style
      &id = \html5chan-style
      &textContent = require \style/html5chan
    &appendChild with L \script
      &src = '//www.google.com/recaptcha/api/challenge?
              k=6Ldp2bsSAAAAAAJ5uyx_lx34lJeEpTLVkP5k04qc'
      &addEventListener \load !->
        head.appendChild with L \script
          &src = \//www.google.com/recaptcha/api/js/recaptcha.js
          &addEventListener \load !->
            L \script
              &textContent =
                # secret secrets, gained from digging around in the recaptcha js
                "(function() {
                  var c;
                  if (c = document.getElementById('captcha')) {
                    Recaptcha._init_options({
                      theme: 'custom',
                      custom_theme_widget: c
                    });
                    Recaptcha.theme = 'custom';
                    Recaptcha.widget = c;
                    Recaptcha._finish_widget();
                  }
                 }())"
              if board.ready
                head.appendChild &
              else
                onready !-> head.appendChild &

body = L \body

# replace the original html with the new, but keep a reference to query and
# parse. This speeds up re-rendering consideraby, since the browser doesn't
# even have to attempt displaying the old content and style.
#
# in fact, it's so effective, even the original sript tags don't run, EVEN ON
# CHROME, negating the need to handle 'beforescriptexeute' or whatever. crazy.
d = document.replaceChild html, document.documentElement

# init
<-! document.addEventListener \DOMContentLoaded
console.profile!

console.time "initial render"

console.time "parse page"
# get other useful information
board
  &title    = d.querySelector \.boardTitle      ?.textContent or ''
  &subtitle = d.querySelector \.boardSubtitle   ?.innerHTML or ''
  &nav      = d.querySelector \#boardNavDesktop  .innerHTML
  &banner   = d.querySelector \.title            .src
  &message  = d.querySelector \.globalMessage   ?.innerHTML

  # detect based on favicon href
  &sfw =
    d.querySelector 'link[rel="shortcut icon"]' .href.slice(-6) is \ws.ico

  &type = if &sfw then \sfw else \nsfw
  &favicon = board.favicons[&type]

  # for post deletion
  &password = get \password or Math.random!toString!substr -8

console.timeEnd "parse page"

console.log board

# if I click a link off of a threadpage that has been updated, then click the
# back button, the updated posts won't appear until the updater hits the
# new version again, i.e. the browser back state is using the old version
# of the page. Thus, check the session storage cache for threads and use
# that instead of reparsing the page, which can't possibly be newer
# information.  TODO invalidate the cache somehow on recompilation (so
# fixing parser bugs will take affect) however, maybe it'll work with
# shift+F5 if that clears sessionStorage

function date-reviver k, v
  if k is \time
    new Date v
  else
    v

if board.is-thread and (thread = sget "cache-#{board.thread-no}" date-reviver)
  console.log "using cached thread data"
  board.thread = thread
  board.threads =[thread]
else
  console.time "parse board"
  board.threads = parser.board d
  console.timeEnd "parse board"
  board.thread = board.threads.0 if board.isThread

# global lookup post by hash
# XXX cross-board still conflicts
board.posts = {}
for board.threads
  for &posts
    board.posts[&no] = &

# XXX used in hide.co, really want IDB/minimongo/'real man's db'
board.threads-by-id = {}
for board.threads
  board.threads-by-id[&no] = &

# console.log board.threads

body
  &id = board.name
  &className = "#{board.type} \
               #{if board.isThread then \threadpage else \boardpage}"

console.time "generate new HTML body"
body-html = board-template board
console.timeEnd "generate new HTML body"

console.time "parse new body HTML"
body.innerHTML = body-html
console.timeEnd "parse new body HTML"

console.time "prerender handlers"
document.dispatchEvent new CustomEvent do
  \html5chan-prerender
  detail: {body}
console.timeEnd "prerender handlers"

console.time "render new body"
html.appendChild body
console.timeEnd "render new body"

if board.isBoard
  console.time "highlight current page"
  body.querySelector "\#pages a[href=\"#{board.page or board.url}\"]"
    .id = \current
  console.timeEnd "highlight current page"

function text
  L \div |>
    &innerHTML = it
    &textContent

console.time "set new page title"
document.title =
  if board.isThread
    board.thread.op |>
      "#{truncate do
           &subject or text &comment or &image?filename or &time.relative-date!}
       \ - /#{board.name}/"
  else
    board.title
console.timeEnd "set new page title"

console.time "set correct favicon"
document.head.append with L \link
  &id   = \favicon
  &rel  = \icon
  &type = \image/x-icon # required for chrome, I guess
  &href = board.favicon.src
console.timeEnd "set correct favicon"

console.timeEnd "initial render"

# rescroll to target element if this page hasn't been scrolled before
# this retains the browser's natural scroll position memory
# while still scrolling to the new hash target's position
# the first time the page loads (or if window hasn't been scrolled)
if window.location.hash and not sget document.URL
  window.location.hash = window.location.hash
  window.addEventListener \scroll function registerPage
    sset {+(document.URL)}
    window.removeEventListener \scroll registerPage

board.ready = true

# cache current thread hash (which is updated by updater)
if board.is-thread
  window.addEventListener \unload !->
    sset "cache-#{board.thread-no}" board.thread

console.time "onready handlers"
document.dispatchEvent new CustomEvent do
  \html5chan-ready
  detail: {board.threads, el: $ \threads}
console.timeEnd "onready handlers"

console.profileEnd!
