# ########################################################
# general page info
# ########################################################
logoEl = document.getElementsByClassName('logo')[0]
centerEls = document.getElementsByTagName 'center'
board =
	name: document.title.match(/\/(\w+)\//)[1] # easiest way to get it 
	title: logoEl.children[2].children[0].children[0].textContent
	subtitle: logoEl.children[4]?.innerHTML
	nsfw: document.styleSheets[0].ownerNode.href is 'http://static.4chan.org/css/yotsuba.9.css' # the yellow theme
	nav: document.getElementById('navtop').innerHTML # I could hard code it, but then I'd miss updates
	banner: document.getElementsByTagName('img')[0].src
board.motd = centerEls[2].innerHTML if centerEls.length > 4 # the captcha, 2 ads, and footer tag are also in center tags
board.url = "http://boards.4chan.org/#{board.name}/"
board.threadurl = "#{board.url}res/"

parse4ChanDate = do ->
	(july = new Date()).setMonth(6)
	DSTOffset = 4 + (new Date().getTimezoneOffset() - july.getTimezoneOffset()) / 60
	->
		unless match = it.match /(\d{2})\/(\d{2})\/(\d{2})\(\w+\)(\d{2}):(\d{2})/
			throw "Couldn't parse date: #{date}"
		new Date Date.UTC do
			parseInt(match[3],10) + 2000
			parseInt(match[1],10) - 1
			parseInt(match[2],10)
			(parseInt(match[4],10) + DSTOffset) % 24 # 4chan is EST
			parseInt(match[5],10)

# in the context of given element
parse4chan = (context) ->
	n = 0 # counter for elements that always exist, starts at -1 for pre-incrementing
	_poster = 0 # need separate counter since capcodes are hidden in this selector
	parsePost = (thread, op, testAttr, testObj) -> 
		p = new Post do
			ids[n].name
			op
			thread
			parse4ChanDate times[n].textContent
			titles[n].textContent
			posters[_poster++].textContent
			comments[n]
			(email = true) and emails.shift().href.substring(7) if emails[0]?.parentNode[testAttr] is testObj
			imageEls.shift() and images.shift() if imageEls[0]?.parentNode[testAttr] is testObj
			!!deletedImages.shift() if deletedImages[0]?[testAttr] is testObj
			# tripcode gets wrapped in the email anchor if present
			(if tripcodes[0] and (if email? then tripcodes[0].parentNode else tripcodes[0])[testAttr] is testObj
				emails.shift() if emails[0]?[testAttr] is testObj # clear extra linkmail element
				tripcodes.shift().textContent
			)
			# capcodes are hidden within reply posters, even for ops
			posters[_poster++].textContent if /##/.test(posters[_poster]?textContent)
			# only applicable on forced anon boards
			if uids[n] and uids[n].textContent is not '(ID: Heaven)'
				uids[n].textContent.match /\(ID: ([^)]+)\)/ .1
		n++
		return p

	# ########################################################
	time "preprocess"
	# ########################################################
	if isThread = document.location.pathname.match /res\/(\d+)/ # also match for thread id
		threadId = isThread[1]
		threadPath = "/#{board.name}/res/"+threadId
		opHash = '#'+threadId
		
		# classify op and crossthread links
		time "classify links"
		for link of context.getElementsByClassName \quotelink
			unless />>>/.test link.textContent # skip crossboard links
				if opHash is link.hash
					link.className += ' oplink'
				else 
					if threadPath is not link.pathname
						link.className += ' crossthread'
		timeEnd "classify links"
	else # board page
		omittedposts = Array::slice.call context.getElementsByClassName \omittedposts
		
		# redo the board pages all nice
		current = parseInt(document.location.pathname.split('/')?[2], 10) or 0
		pages = for i to 15 # let's assume they all have 15 pages
			{ num: i, current: current is i }
		next = if current < 15 then current + 1
		previous = if current > 0 then current - 1

	time "label elements"
	numThreads = 0
	for el of context.children # our wonderful parent element
		break if el.tagName is "CENTER" # the ad at the end of the threads
		if el.tagName is "HR"
			numThreads++
			continue
		el.threadNum = numThreads # oh so horrible
	timeEnd "label elements"
	
	fileinfos = context.getElementsByClassName \filesize
	imageEls = Array::slice.call context.querySelectorAll 'img[md5]'
	images = for thumb,i of imageEls
		dimensions = fileinfos[i].innerHTML.match /(\d+)x(\d+)/
		new Image do		
			thumb:
				url: thumb.src
				width: thumb.width
				height: thumb.height
			url: thumb.parentNode.href
			
			width: parseInt dimensions[1], 10
			height: parseInt dimensions[2], 10
			
			size: thumb.alt.match(/[\d\.]+ [KM]?B/)[0]
			filename: fileinfos[i].innerHTML.match(/title="([^"]+)"/)?[1]
			md5: thumb.getAttribute 'md5'
			
			spoiler: /^Spoiler Image/.test thumb.alt
	
	ids = context.querySelectorAll 'input[value="delete"]'
	times = context.getElementsByClassName \posttime

	uids = context.getElementsByClassName \posteruid # /b/'s forced anon

	emails = Array::slice.call context.getElementsByClassName('linkmail')
	tripcodes = Array::slice.call context.getElementsByClassName('postertrip')
	deletedImages = Array::slice.call context.querySelectorAll('img[alt="File deleted."]')

	time "clean comments"
	comments = for el of context.getElementsByTagName \blockquote
		el.innerHTML
			.replace(/onmouseover="this\.style\.color='#FFF';" onmouseout="this\.style\.color=this\.style\.backgroundColor='#000'" style="color:#000;background:#000"/g, "") # annoying spoiler tags
			.replace(/onclick="replyhl\('\d+'\);"/g, "") # do not want
			.replace(/<font class="unkfunc">(<a[^q]+quotelink[^>]+>&gt;&gt;\d+<\/a>[^<]*)<\/font>/g, "$1") # unwrap single quote links
			.replace(/<font class="unkfunc">/g, '<font class="greentext">') # unkfunc?
			.replace(/([^"']|^)(https?:\/\/[\w\.\-_\/=&;?#%:~!]+)/g,'$1<a href="$2" target="_blank">$2</a>') # linkify links not preceded by a quote or double-quote (should avoid relinkifying href= urls)

	timeEnd "clean comments"
	
	posters = context.querySelectorAll '.postername, .commentpostername'

	titles = context.querySelectorAll '.filetitle, .replytitle'

	replyEls = context.getElementsByClassName \reply

	# stickies are at the top, so we just need the number of them
	stickies = context.querySelectorAll('img[alt="sticky"]').length
	# we could probably assume locked threads are too, but we'll be safe
	closedThreads = Array::slice.call context.querySelectorAll('img[alt="closed"]')
	timeEnd "preprocess"
	# ########################################################
	time "create objects"
	# ########################################################
	threads = for i til numThreads
		thread = new Thread ids[n].name, !isThread
		thread.op = parsePost thread, true, "threadNum", i
		thread.replies = (parsePost(thread,false,"parentNode", el) if el.parentNode.parentNode.parentNode.threadNum is i for el of replyEls) # walk to table from td
		if closedThreads[0]?.parentNode.threadNum is i
			closedThreads.shift()
			thread.locked = true
		if stickies > 0
			stickies--
			thread.sticky = true
		if !isThread and omittedposts[0]?.threadNum is i
			omitted = omittedposts.shift().textContent
			thread.omitted =
				replies: parseInt(omitted.match(/\d+(?= posts?)/), 10) or 0
				imageReplies: parseInt(omitted.match(/\d+(?= image (?:replies|reply))/), 10) or 0
				shown: thread.replies.length # weird wording, i know, but for rendering
		
		thread # return thread to threads
	timeEnd "create objects"
	# ########################################################
	# return 
	# ########################################################
	board: board
	
	isThread: !!isThread
	isBoard: !isThread
	threadId: threadId
	locked: if isThread then threads[0].locked
	
	thread: threads[0] if isThread
	threads: threads
	
	pages: pages
	previous: previous
	next: next

time "parse"
data = parse4chan document.querySelector('form[name="delform"]')
timeEnd "parse"
