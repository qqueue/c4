dimension-regex = /(\d+)x(\d+)/
size-regex      = /[\d\.]+ [KM]?B/
filename-regex  = /title="([^"]+)"/
spoiler-regex   = /^Spoiler Image/
sage-regex      = /^sage$/i

enhancer = require \./enhancer

# pre-querying board parser, to hopefully speed things up
function parse-board document, board
  thumbs-base = "//thumbs.4chan.org/#board/thumb/"
  images-base = "//images.4chan.org/#board/src/"
  thread-url  = "//boards.4chan.org/#board/res/"

  # pre-query always-existant post elements, which should be faster than
  # individual querySelector calls
  times    =  document.querySelectorAll \.dateTime
  comments =  document.querySelectorAll \.postMessage
  names    =  document.querySelectorAll \.name
  subjects =  document.querySelectorAll \.subject

  # some elements exist on both .mobile info and .desktop info, because moot,
  # so bicrement past .mobile versions
  e-idx = 0
  b-idx = 1

  for document.querySelectorAll \.thread
    t = new Thread do
      &
      times
      comments
      names
      subjects
      e-idx
      b-idx
      thumbs-base
      images-base
      thread-url

    t.posts.length
      e-idx += &
      b-idx += & * 2

    t

class Thread then (el, times, comments, names, subjects, e-idx, b-idx, thumbs-base,
                   images-base, thread-url) ->
  @no        = el.id.substring 1 # t12345
  @url       = thread-url + @no

  @omitted = if omitted = el.querySelector \.summary
    replies:
      parseInt omitted.textContent.match(/\d+(?= posts?)/), 10 or 0
    imageReplies:
      parseInt omitted.textContent.match(/\d+(?= image (?:replies|reply))/), 10 or 0

  @preview = !!omitted

  @sticky = el.querySelector(\.stickyIcon)?
  @closed = el.querySelector(\.closedIcon)?

  @op     = new Post do
    this
    el.querySelector( \.op )
    0
    true
    times[b-idx]
    comments[e-idx]
    names[b-idx]
    subjects[b-idx]
    thumbs-base
    images-base
  ++e-idx
  b-idx += 2

  idx = 1 + (@omitted?replies || 0)
  @replies = for el.getElementsByClassName( \reply )
    p = new Post do
      this
      &
      idx++
      false
      times[b-idx]
      comments[e-idx]
      names[b-idx]
      subjects[b-idx]
      thumbs-base
      images-base

    ++e-idx
    b-idx += 2

    p

  @postprocess!

Thread::postprocess = ->
  #convenience array including op
  @posts = [@op, ...@replies]

  @imageReplies = []

  # build reply hash and image replies array
  @reply = {}
  for reply of @replies
    @imageReplies.push reply if reply.image
    @reply[reply.no] = reply

  Thread[@no] = this

class Post then (thread, el, @idx, @op, time-el, comment-el, name-el, subject-el,
                 thumbs-base, images-base) ->
  @no  = el.id.substring 1

  @url = "#{thread.url}\#p#{@no}"

  @time = new Date parseInt(time-el.dataset.utc, 10) * 1000ms

  @subject  = subject-el.innerHTML

  @name     = name-el.innerHTML
  @tripcode = el.querySelector \.postertrip                ?.innerHTML
  @capcode  = el.querySelector \.capcode                   ?.innerHTML

  @email    = el.querySelector \.useremail ?.href.substring(7) # strip mailto=
  @sage     = sage-regex.test that if @email

  @comment  = enhancer.enhance comment-el.innerHTML

  @uid = el.querySelector \.hand ?.textContent # hand?

  img = el.querySelector \.fileThumb

  @deleted-image = img?firstElementChild.alt is "File deleted."
  @image = if img and not @deleted-image
    new FImage img, el, thumbs-base, images-base

class FImage then (el, postel, thumbs-base, images-base) ->
  # use getAttribute because `href` property adds the protocol, while
  # getAttribute returns the protocolless //version (the text of the
  # actual html attribute)
  @url        = el.getAttribute \href

  info       = postel.querySelector \.fileInfo .innerHTML
  dimensions = dimension-regex.exec info
  thumb      = el.firstElementChild
  timestamp  = @url.match /\/(\d+)/ .1

  @thumb     = new Thumb timestamp, thumb, thumbs-base

  @width     = parseInt dimensions.1, 10
  @height    = parseInt dimensions.2, 10

  @size      = size-regex.exec thumb.alt .0
  @filename  = filename-regex.exec(info)?1
  @md5       = thumb.dataset.md5

  @spoiler  = spoiler-regex.test thumb.alt

class Thumb then (timestamp, el, thumbs-base) ->
  @url    = thumbs-base + "#{timestamp}s.jpg"
  # FIXME when image is spoiled, these are the spoiler image size.
  # Since 4chan doesn't expose tn_{w|h} in the HTML, will probably need
  # to clamp to 152wx151h (and 252x251 for OPs) manually if spoiled
  @width  = parseInt el.style.width, 10
  @height = parseInt el.style.height, 10

# alternate constructor from 4chan JSON API
APIThread:: = Thread::
!function APIThread {posts: [op, ...replies]}: data, board
  thumbs-base = "//thumbs.4chan.org/#board/thumb/"
  images-base = "//images.4chan.org/#board/src/"
  thread-url  = "//boards.4chan.org/#board/res/"
  @no  = op.no
  @url = thread-url + op.no

  @preview = !!op.omitted_posts
  @sticky  = !!op.sticky
  @closed  = !!op.closed

  @op      = new APIPost this, op, 0, images-base, thumbs-base
  idx = 1 + (op.omitted_posts || 0)
  @replies = for replies => new APIPost this, &, idx++, images-base, thumbs-base

  @postprocess!

APIPost:: = Post::
!function APIPost thread, data, @idx, images-base, thumbs-base
  @<<< data{
    no
    subject: sub
    name
    tripcode: trip
    uid: id
    capcode
    email
  }

  @url           = "#{thread.url}\#p#{data.no}"
  @time          = new Date data.time * 1000

  @sage          = data.email is \sage
  @comment       = if data.com then enhancer.enhance that else ''

  @deleted-image = !!data.filedeleted
  @image         = if data.fsize then new APIImage data, images-base, thumbs-base

APIImage:: = FImage::
!function APIImage data, images-base, thumbs-base
  @thumb = new APIThumb data, thumbs-base

  @url      = images-base + data.tim + data.ext

  @width    = data.w
  @height   = data.h

  @size     = humanized data.fsize
  @filename = data.filename + data.ext
  @md5      = data.md5

  @spoiler  = !!data.spoiler

APIThumb:: = Thumb::
!function APIThumb data, thumbs-base
  @url    = thumbs-base + data.tim + \s.jpg
  @width  = data.tn_w
  @height = data.tn_h

export
  board: parse-board
  api: (data, board) -> new APIThread data, board

function humanized bytes
  if bytes < 1024
    "#bytes B"
  else if (kbytes = Math.round bytes / 1024) < 1024
    "#kbytes KB"
  else
    "#{(kbytes / 1024)toString!substring 0 3} MB"
