dimension-regex = /(\d+)x(\d+)/
size-regex      = /[\d\.]+ [KM]?B/
filename-regex  = /title="([^"]+)"/
spoiler-regex   = /^Spoiler Image/
sage-regex      = /^sage$/i

Thread = require \./classes/Thread
Post = require \./classes/Post
enhancer = require \./enhancer

parse-thread = (el) -> new Thread
  &no        = el.id.substring 1 # t12345
  &url       = board.threadurl + &no

  &omitted = if omitted = el.querySelector \.summary
    replies:
      parseInt(omitted.textContent.match(/\d+(?= posts?)/), 10) or 0
    imageReplies:
      parseInt(omitted.textContent.match(/\d+(?= image (?:replies|reply))/), 10) or 0

  &preview = !!omitted

  &sticky = el.querySelector(\.stickyIcon)? # XXX implicit call doens't work with ?
  &closed = el.querySelector(\.closedIcon)?

  &op     = parse-post.call (&), el.querySelector( \.op )
  &op.idx = 0

  &replies = Array::map.call do
    el.getElementsByClassName( \reply )
    parse-post
    & # this for map calls

  &postprocess!

parse-post = (el, idx) ->
  thread = this
  img = el.querySelector \.fileThumb

  idx : 1 + idx + (thread.omitted?replies || 0)
  no  : no = el.id.substring 1

  op  : op = el.classList.contains \op
  url : if op then thread.url else "#{thread.url}\#p#no"

  time : new Date do
    parseInt( el.querySelector( \.dateTime ).dataset.utc, 10 ) * 1000ms

  subject  : el.querySelector '.postInfo.desktop .subject' .innerHTML

  name     : el.querySelector \.name                       .innerHTML
  tripcode : el.querySelector \.postertrip                ?.innerHTML
  capcode  : el.querySelector \.capcode                   ?.innerHTML

  email    : email = el.querySelector \.useremail ?.href.substring(7) # strip mailto:
  sage     : sage-regex.test that if email

  comment  : enhancer.enhance do
   el.querySelector \.postMessage .innerHTML

  uid : el.querySelector \.hand ?.textContent # hand?

  deleted-image : deleted-image = img?firstElementChild.alt is "File deleted."
  image : if img and not deleted-image
    thumb      = img.firstElementChild

    # use getAttribute because `href` property adds the protocol, while
    # getAttribute returns the protocolless //version (the text of the
    # actual html attribute)
    url        = img.getAttribute \href
    timestamp  = url.match /\/(\d+)/ .1

    info       = el.querySelector \.fileInfo .innerHTML
    dimensions = dimension-regex.exec info

    thumb :
     # since thumb's href is spoiler sometimes, recalc
     # FIXME doesn't work for crossboard fetches
     url    : "//thumbs.4chan.org/#{board.name}/thumb/#{timestamp}s.jpg"
     # FIXME when image is spoiled, these are the spoiler image size.
     # Since 4chan doesn't expose tn_{w|h} in the HTML, will probably need
     # to clamp to 152wx151h (and 252x251 for OPs) manually if spoiled
     width  : parseInt thumb.style.width, 10
     height : parseInt thumb.style.height, 10

    url      : url

    width    : parseInt dimensions.1, 10
    height   : parseInt dimensions.2, 10

    size     : size-regex.exec thumb.alt .0
    filename : filename-regex.exec(info)?1
    md5      : thumb.dataset.md5

    spoiler  : spoiler-regex.test thumb.alt

# TODO clean up this code
module.exports =
  # returns Array of threads
  board: (document) ->
    console.time "parse board"
    threads = Array::map.call do
      document.querySelectorAll \.thread
      parse-thread
    console.timeEnd "parse board"

    return threads

  thread: (document) ->
    console.time "parse thread"
    thread = parse-thread document.querySelector \.thread
    console.timeEnd "parse thread"

    return thread

  # transform API thread format to the data used here. Returns Thread.
  api: ({posts: [op]}: data) -> new Thread
    &no  = op.no
    &url = board.threadurl + op.no

    &preview = !!op.omitted_posts
    &sticky  = !!op.sticky
    &closed  = !!op.closed

    &[\op ...\replies] = data.posts.map parse-api-post, &

    &postprocess!

# TODO cross-board linking will break this
thumbs-base = "//thumbs.4chan.org/#{board.name}/thumb/"
images-base = "//images.4chan.org/#{board.name}/src/"

humanized = (bytes) ->
  if bytes < 1024
    "#bytes B"
  else if (kbytes = Math.round bytes / 1024) < 1024
    "#kbytes KB"
  else
    "#{(kbytes / 1024)toString!substring 0 3} MB"

# "this" is thread
parse-api-post = (data, i) ->
  idx           : i
  thread        : this
  url           : "#{@url}#p#{data.no}"
  time          : new Date data.time * 1000

  no            : data.no
  subject       : data.sub
  name          : data.name
  tripcode      : data.trip
  uid           : data.id
  capcode       : data.capcode
  email         : data.email

  sage          : data.email is \sage
  comment       : if data.com then enhancer.enhance that else ''

  deleted-image : !!data.filedeleted
  image         : if data.fsize
    thumb:
      url    : thumbs-base + data.tim + \s.jpg
      width  : data.tn_w
      height : data.tn_h

    url      : "#{images-base}#{data.tim}#{data.ext}"

    width    : data.w
    height   : data.h

    size     : humanized data.fsize
    filename : "#{data.filename}#{data.ext}"
    md5      : data.md5

    spoiler  : !!data.spoiler


