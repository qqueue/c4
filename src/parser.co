# lots of repetition in the interest of speed:
# * no conversion of NodeList to Array
# * as few method calls as possible
# * use indices instead of Array.push/shift
#
# and no, I don't trust spidermonkey/v8 to inline my shit automatically

# convert from EST (4chan time) to local time
# using explicitly set date in july, to ensure
# no daylight savings, which EST offset = 4 assumes
# in milliseconds so it can be subtracted from unix time
timezone =  (4*60min - new Date( new Date!.setMonth(6) ).getTimezoneOffset! )*60sec*1000ms
# this exploits the format of 4chan dates:
# MM/DD/YY(weekday)HH:MM, which V8/Chrome will parse outright
# but firefox won't, so we have to regex it into a form that will work in
# both engines: MM/DD/YYYY HH:MM, as well as add the timezone
time_regex = /(\d{2}\/\d{2}\/)(\d{2})(\(\w+\))(\d{2})(:\d{2})/
time_replace = '$120$2 $4$5' # adds 21st century to year and removes weekday
# this function is manually inlined
# parser.date = -> new Date( Date.parse( it.replace time_regex, time_replace ) + timezone )

# returns Array of threads
# TODO combine image regexes 
parser.board =  (document) ->
	time "parse board"
	time "select elements"
	# everything relevent is in the delform, so we can make queries to it
	# (probably) faster than the entire document
	delform = document.querySelector 'form[name="delform"]'

	# to reduce the number of DOM queries, pull out some attribute's elements
	# separately, instead of nested queries inside each comment
	# however, attributes that can be gotten through tree walking, like
	# tripcodes or images, are not queried at all

	# these elements can be selected for easily, since they exist in every post
	# getElementsBy{Tag|Class}Name is marginally faster than querySelector
	comments = delform.getElementsByTagName \blockquote
	times = delform.getElementsByClassName \posttime
	uids = delform.getElementsByClassName \posteruid

	post = 0 # to avoid Array.shift! calls, keep a common iterator to the above NodeLists
	
	# finding the ids from the delete checkbox values is faster than trying to
	# select the permalinks, or the named anchors
	ids = delform.querySelectorAll 'input[value="delete"]'

	# these things exist only in replies
	reply_titles = delform.getElementsByClassName \replytitle

	# op titles are inexplicably filetitles
	op_titles = delform.getElementsByClassName \filetitle

	# since stickies are by definition on the top, we'll just grab the count
	stickies = delform.querySelectorAll 'img[alt="sticky"]' .length

	# locked thread icon, and some bookkeeping
	locks = delform.querySelectorAll 'img[alt="closed"]'
	locked_threads = locks.length
	current_lock = 0

	# reply elements, for all the threads, which will be sorted out later
	replies = delform.getElementsByClassName \reply
	num_replies = replies.length
	current_reply = 0 # idx

	# there is one <a name="0"> for each thread
	anchors = delform.querySelectorAll 'a[name="0"]'

	timeEnd "select elements"

	time "create objects"

	threads = []
	for anchor, thread_num of anchors
		t = new Thread
		t.id = ids[post].name # this is also the OP's id
		t.url = board.threadurl + t.id
		t.preview = true

		# after OP:
		# <blockquote>
		# <span.omittedposts>
		if (omitted = comments[post].nextElementSibling)?className is \omittedposts
			t.omitted = 
				replies: parseInt(omitted.textContent.match(/\d+(?= posts?)/), 10) or 0
				imageReplies: parseInt(omitted.textContent.match(/\d+(?= image (?:replies|reply))/), 10) or 0

		t.sticky = !!stickies-- if stickies > 0 # true if there are more stickies
		if locked_threads > 0 and current_lock < locked_threads
			# exploit the fact that locked icon is in the span#nothread<threadid>
			# node, which we can test against the thread id
			if locks[current_lock].parentNode.id.substring(8) is t.id
				t.locked = true
				++locked_threads
		
		t.op = op = new Post
		op.id = ids[post].name
		op.op = true 
		op.thread = t # circular reference for rendering
		op.time = new Date( Date.parse( times[post].textContent.replace time_regex, time_replace ) + timezone )
		op.title = (title = op_titles[thread_num]).textContent
		op.poster = (poster = title.nextElementSibling).textContent
		op.uid = uids[post]?textContent
		op.comment = parser.enhance comments[post]

		# email is always wrapped in a postername, substring 7 strips 'mailto:'
		op.email = poster.firstElementChild?href?substring 7

		# image detection:
		# <span.filesize>
		# <br>
		# <a.thumbnail>
		# <a name="0"> <-- for every thread
		if (thumb = anchor.previousElementSibling )?href # detect thumbnail link
			# <span.filesize>
			info = thumb.previousElementSibling.previousElementSibling.innerHTML
			thumb.=firstElementChild # img inside link	
			dimensions = info.match /(\d+)x(\d+)/
			op.image = 
				thumb:
					url: thumb.src
					width: thumb.width
					height: thumb.height
				url: thumb.parentNode.href
				
				width: parseInt dimensions[1], 10
				height: parseInt dimensions[2], 10
				
				size: thumb.alt.match(/[\d\.]+ [KM]?B/)[0]
				filename: info.match(/title="([^"]+)"/)?[1]
				md5: thumb.getAttribute 'md5'
				
				spoiler: /^Spoiler Image/.test thumb.alt

		# TODO op.deletedImage = once I find a deleted image

		# trips always follow posters, unless they have an email, in which case
		# they are maddening wrapped INSIDE the linkmail
		if (trip = poster.nextElementSibling).className is \postertrip or trip.className is \linkmail
			op.tripcode = trip.textContent

		# capcodes follow either postername for Anonymous ## Mod
		# or tripcode for Moot ## Admin
		if ( op.tripcode and (cap = trip.nextElementSibling).firstElementChild ) or ( !op.tripcode and (cap = poster.nextElementSibling).firstElementChild )
			op.capcode = cap.textContent

		op.postprocess! # run backlinker and other stuff

		++post # flush OP's attributes

		t.replies = []

		# the next reply's table outer element's 2nd previous sibling is either
		# the omitted replies indicator, or the OP's comment. If it's not, 
		# than this thread has no replies:
		# <omitted> or <blockquote>
		# <a name="">
		# <first reply table>
		before_first_reply_table = replies[current_reply]?parentNode.parentNode.parentNode.previousElementSibling.previousElementSibling
		if before_first_reply_table is omitted or before_first_reply_table is comments[post - 1]
			reply_idx = 0 # idx for thread's current replies
			for ever # this loop breaks at the end of each thread
				td = replies[current_reply] 

				r = new Post
				r.id = ids[post].name
				r.op = false
				r.thread = t
				r.time = new Date( Date.parse( times[post].textContent.replace time_regex, time_replace ) + timezone )
				r.title = (title = reply_titles[current_reply]).textContent
				r.poster = (poster = title.nextElementSibling).textContent
				r.uid = uids[post]?textContent
				r.comment = parser.enhance comments[post]

				r.email = poster.firstElementChild?href?substring 7

				#	<span.filesize>
				#	<br>
				#	<a.thumbnail>
				#	<blockquote> <-- comment
				if (thumb = comments[post].previousElementSibling )?href # detect thumbnail link
					# <span.filesize>
					info = thumb.previousElementSibling.previousElementSibling.innerHTML
					thumb.=firstElementChild # img inside link	
					dimensions = info.match /(\d+)x(\d+)/
					r.image = 
						thumb:
							url: thumb.src
							width: thumb.width
							height: thumb.height
						url: thumb.parentNode.href
						
						width: parseInt dimensions[1], 10
						height: parseInt dimensions[2], 10
						
						size: thumb.alt.match(/[\d\.]+ [KM]?B/)[0]
						filename: info.match(/title="([^"]+)"/)?[1]
						md5: thumb.getAttribute 'md5'
						
						spoiler: /^Spoiler Image/.test thumb.alt

				# TODO r.deletedImage = once I find a deleted image

				# trips always follow posters, unless they have an email, in which case
				# they are maddening wrapped INSIDE the linkmail
				if (trip = poster.nextElementSibling).className is \postertrip or trip.className is \linkmail
					r.tripcode = trip.textContent

				# capcodes follow either postername for Anonymous ## Mod
				# or tripcode for Moot ## Admin
				if ( r.tripcode and (cap = trip.nextElementSibling).firstElementChild ) or ( !r.tripcode and (cap = poster.nextElementSibling).firstElementChild )
					r.capcode = cap.textContent
				
				r.postprocess!

				t.replies[reply_idx] = r # add reply to array
				++post # increment index for attributes
				++reply_idx
				++current_reply

				# if <td>.<tr>.<tbody>.<table> is followed by a BR instead of an anchor
				# it is the last reply for this thread (cool huh)
				break if td.parentNode.parentNode.parentNode.nextElementSibling.tagName is \BR

		t.postprocess! # thread references and other stuff
		threads[thread_num] = t

	timeEnd "create objects"
	timeEnd "parse board"
	return threads

# copypasta, copypasta everywhere
# returns the Thread
parser.thread = (document) ->
	/*
	# classify op and crossthread links
	time "classify links"
	for link of context.getElementsByClassName \quotelink
		unless />>>/.test link.textContent # skip crossboard links
			if opHash is link.hash
				link.className += ' oplink'
			else if link.pathname and link.pathname is not threadPath
				link.className += ' crossthread'
	timeEnd "classify links"
	*/
	parser.last_parse = Date.now!
	time "parse thread"
	time "select elements"
	delform = document.querySelector 'form[name="delform"]'

	comments = delform.getElementsByTagName \blockquote
	times = delform.getElementsByClassName \posttime
	uids = delform.getElementsByClassName \posteruid
	post = 0 
	
	ids = delform.querySelectorAll 'input[value="delete"]'

	replies = delform.getElementsByClassName \reply
	reply_titles = delform.getElementsByClassName \replytitle

	timeEnd "select elements"

	time "create objects"
	t = new Thread
	t.id = ids[post].name # this is also the OP's id
	t.url = board.threadurl + t.id

	t.locked = !!delform.querySelector 'img[alt="closed"]'
	
	t.op = op = new Post
	op.id = ids[post].name
	op.op = true 
	op.thread = t # circular reference for rendering
	op.time = new Date( Date.parse( times[post].textContent.replace time_regex, time_replace ) + timezone )
	op.title = (title = delform.getElementsByClassName('filetitle').0).textContent
	op.poster = (poster = title.nextElementSibling).textContent
	op.uid = uids[post]?textContent
	op.comment = parser.enhance comments[post]

	# email is always wrapped in a postername, substring 7 strips 'mailto:'
	op.email = poster.firstElementChild?href?substring 7
	
	# image detection:
	# <delform>
	#   <span.filesize>
	#   <br>
	#   <a.thumbnail>
	if (filesize = delform.firstElementChild )?className is \filesize # detect filesize
		info = filesize.innerHTML
		thumb = filesize.nextElementSibling.nextElementSibling.firstElementChild # img inside link
		dimensions = info.match /(\d+)x(\d+)/
		op.image = 
			thumb:
				url: thumb.src
				width: thumb.width
				height: thumb.height
			url: thumb.parentNode.href
			
			width: parseInt dimensions[1], 10
			height: parseInt dimensions[2], 10
			
			size: thumb.alt.match(/[\d\.]+ [KM]?B/)[0]
			filename: info.match(/title="([^"]+)"/)?[1]
			md5: thumb.getAttribute 'md5'
			
			spoiler: /^Spoiler Image/.test thumb.alt

	# TODO op.deletedImage = once I find a deleted image

	# trips always follow posters, unless they have an email, in which case
	# they are maddening wrapped INSIDE the linkmail
	if (trip = poster.nextElementSibling).className is \postertrip or trip.className is \linkmail
		op.tripcode = trip.textContent

	# capcodes follow either postername for Anonymous ## Mod
	# or tripcode for Moot ## Admin
	if ( op.tripcode and (cap = trip.nextElementSibling).firstElementChild ) or ( !op.tripcode and (cap = poster.nextElementSibling).firstElementChild )
		op.capcode = cap.textContent

	op.postprocess! # run backlinker and other stuff

	++post # flush OP's attributes

	t.replies = []

	for td, i of replies
		r = new Post
		r.id = ids[post].name
		r.op = false
		r.thread = t
		r.time = new Date( Date.parse( times[post].textContent.replace time_regex, time_replace ) + timezone )
		r.title = (title = reply_titles[i]).textContent
		r.poster = (poster = title.nextElementSibling).textContent
		r.uid = uids[post]?textContent
		r.comment = parser.enhance comments[post]

		r.email = poster.firstElementChild?href?substring 7

		#	<span.filesize>
		#	<br>
		#	<a.thumbnail>
		#	<blockquote> <-- comment
		if (thumb = comments[post].previousElementSibling )?href # detect thumbnail link
			# <span.filesize>
			info = thumb.previousElementSibling.previousElementSibling.innerHTML
			thumb.=firstElementChild # img inside link	
			dimensions = info.match /(\d+)x(\d+)/
			r.image = 
				thumb:
					url: thumb.src
					width: thumb.width
					height: thumb.height
				url: thumb.parentNode.href
				
				width: parseInt dimensions[1], 10
				height: parseInt dimensions[2], 10
				
				size: thumb.alt.match(/[\d\.]+ [KM]?B/)[0]
				filename: info.match(/title="([^"]+)"/)?[1]
				md5: thumb.getAttribute 'md5'
				
				spoiler: /^Spoiler Image/.test thumb.alt

		# TODO r.deletedImage = once I find a deleted image

		# trips always follow posters, unless they have an email, in which case
		# they are maddening wrapped INSIDE the linkmail
		if (trip = poster.nextElementSibling).className is \postertrip or trip.className is \linkmail
			r.tripcode = trip.textContent

		if ( r.tripcode and (cap = trip.nextElementSibling).firstElementChild ) or ( !r.tripcode and (cap = poster.nextElementSibling).firstElementChild)
			r.capcode = cap.textContent
		
		r.postprocess!
		++post

		t.replies[i] = r # add reply to array

	t.postprocess! # thread references and other stuff

	timeEnd "create objects"
	timeEnd "parse thread"
	return t
