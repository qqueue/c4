parser.date = do ->
	# convert from EST (4chan time) to local time
	# using explicitly set date in july, to ensure
	# no daylight savings, which EST offset = 4 assumes
	timezone = 4 - new Date( new Date!.setMonth(6) ).getTimezoneOffset! / 60
	->
		unless match = it.match /(\d{2})\/(\d{2})\/(\d{2})\(\w+\)(\d{2}):(\d{2})/
			throw "Couldn't parse date: #{date}"
		new Date do
			parseInt( match.3, 10 ) + 2000
			parseInt( match.1, 10 ) - 1
			parseInt( match.2, 10 )
			( parseInt( match.4, 10 ) + timezone ) % 24
			parseInt( match.5, 10 )

# in the context of given document
# TODO need to split this up into board and thread parsers
# while still sharing some parts, since a lot of the logic
# is working around stupid board pages
parser.yotsuba = (document, {preview, threadPath} = {preview: board.isBoard, threadPath: board.threadPath}) ->
	# TODO this is a hack to avoid reparsing 
	# move this to updater, or to onready
	# if last-modified on the ajax call is less than this
	parser.last_parse = Date.now!

	context = document.querySelector 'form[name="delform"]'
	n = 0 # counter for elements that always exist
	_poster = 0 # need separate counter since capcodes are hidden in this selector
	parsePost = (thread, op, testAttr, testObj) -> 
		p = new Post do
			ids[n].name
			op
			thread
			parser.date times[n].textContent
			titles[n].textContent
			posters[_poster++].textContent
			comments[n]
			(email = true) and emails.shift().href.substring(7) if emails[0]?.parentNode[testAttr] is testObj
			imageEls.shift() and images.shift() if imageEls[0]?.parentNode[testAttr] is testObj
			!!deletedImages.shift() if deletedImages[0]?[testAttr] is testObj
			# tripcode gets wrapped in the email anchor if present
			(if tripcodes[0] and (if email? then tripcodes[0].parentNode else tripcodes[0])[testAttr] is testObj
				emails.shift() if emails[0]?[testAttr] is testObj # clear extra linkmail element
				tripcodes.shift().textContent
			)
			# capcodes are hidden within reply posters, even for ops
			posters[_poster++].textContent if /##/.test(posters[_poster]?textContent)
			# only applicable on forced anon boards
			if uids[n] and uids[n].textContent is not '(ID: Heaven)'
				uids[n].textContent.match /\(ID: ([^)]+)\)/ .1
		n++
		return p

	# ########################################################
	time "preprocess"
	# ########################################################
	if not preview
		opHash = '#'+board.threadId
		
		# classify op and crossthread links
		time "classify links"
		for link of context.getElementsByClassName \quotelink
			unless />>>/.test link.textContent # skip crossboard links
				if opHash is link.hash
					link.className += ' oplink'
				else if link.pathname and link.pathname is not threadPath
					link.className += ' crossthread'
		timeEnd "classify links"
	else # board page
		omittedposts = Array::slice.call context.getElementsByClassName \omittedposts
		
	time "label elements"
	numThreads = 0
	for el of context.children # our wonderful parent element
		break if el.tagName is "CENTER" # the ad at the end of the threads
		if el.tagName is "HR"
			numThreads++
			continue
		el.threadNum = numThreads # oh so horrible
	timeEnd "label elements"
	
	fileinfos = context.getElementsByClassName \filesize
	imageEls = Array::slice.call context.querySelectorAll 'img[md5]'
	images = for thumb,i of imageEls
		dimensions = fileinfos[i].innerHTML.match /(\d+)x(\d+)/
		thumb:
			url: thumb.src
			width: thumb.width
			height: thumb.height
		url: thumb.parentNode.href
		
		width: parseInt dimensions[1], 10
		height: parseInt dimensions[2], 10
		
		size: thumb.alt.match(/[\d\.]+ [KM]?B/)[0]
		filename: fileinfos[i].innerHTML.match(/title="([^"]+)"/)?[1]
		md5: thumb.getAttribute 'md5'
		
		spoiler: /^Spoiler Image/.test thumb.alt
	
	ids = context.querySelectorAll 'input[value="delete"]'
	times = context.getElementsByClassName \posttime

	uids = context.getElementsByClassName \posteruid # /b/'s forced anon

	emails = Array::slice.call context.getElementsByClassName('linkmail')
	tripcodes = Array::slice.call context.getElementsByClassName('postertrip')
	deletedImages = Array::slice.call context.querySelectorAll('img[alt="File deleted."]')

	time "clean comments"
	comments = for el of context.getElementsByTagName \blockquote
		parser.enhance el
		
	timeEnd "clean comments"
	
	posters = context.querySelectorAll '.postername, .commentpostername'
	titles = context.querySelectorAll '.filetitle, .replytitle'
	replyEls = context.getElementsByClassName \reply

	# stickies are at the top, so we just need the number of them
	stickies = context.querySelectorAll('img[alt="sticky"]').length
	# we could probably assume locked threads are too, but we'll be safe
	closedThreads = Array::slice.call context.querySelectorAll('img[alt="closed"]')
	timeEnd "preprocess"
	# ########################################################
	time "create objects"
	# ########################################################
	threads = for i til numThreads
		new Thread ids[n].name, preview, ->
			@op = parsePost this, true, \threadNum, i
			@replies = for el of replyEls 
				if el.parentNode.parentNode.parentNode.threadNum is i # walk to table from td
					parsePost this, false, \parentNode, el 
			if closedThreads[0]?parentNode.threadNum is i
				@locked = !!closedThreads.shift()
			@sticky = !!stickies-- if stickies > 0

			if preview and omittedposts[0]?.threadNum is i
				omitted = omittedposts.shift().textContent
				@omitted =
					replies: parseInt(omitted.match(/\d+(?= posts?)/), 10) or 0
					imageReplies: parseInt(omitted.match(/\d+(?= image (?:replies|reply))/), 10) or 0
		
	timeEnd "create objects"

	thread: threads[0] unless preview
	threads: threads

