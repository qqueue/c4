dimension-regex = /(\d+)x(\d+)/
size-regex      = /[\d\.]+ [KM]?B/
filename-regex  = /title="([^"]+)"/
spoiler-regex   = /^Spoiler Image/
sage-regex      = /^sage$/i

Thread = require \./classes/Thread
Post = require \./classes/Post
enhancer = require \./enhancer

parse-thread = (el) -> new Thread
  &no        = el.id.substring 1 # t12345
  &url       = board.threadurl + &no

  &omitted = if omitted = el.querySelector \.summary
    replies:
      parseInt(omitted.textContent.match(/\d+(?= posts?)/), 10) or 0
    imageReplies:
      parseInt(omitted.textContent.match(/\d+(?= image (?:replies|reply))/), 10) or 0

  &preview = !!omitted

  &sticky = el.querySelector(\.stickyIcon)? # XXX implicit call doens't work with ?
  &closed = el.querySelector(\.closedIcon)?

  &op     = parse-post.call (&), el.querySelector( \.op )
  &op.idx = 0

  &replies = Array::map.call do
    el.getElementsByClassName( \reply )
    parse-post
    & # this for map calls

  &postprocess!

parse-post = (el, idx) ->
  thread = this

  new Post
    &idx    = 1 + idx + (thread.omitted?replies || 0)
    &thread = thread
    &no     = el.id.substring 1

    &url =
      if &op = el.classList.contains \op
        thread.url
      else
        "#{thread.url}\#p#{&no}"

    &time = new Date do
      parseInt( el.querySelector( \.dateTime ).dataset.utc, 10 ) * 1000ms

    &subject  = el.querySelector '.postInfo.desktop .subject' .innerHTML

    &name     = el.querySelector \.name                       .innerHTML
    &tripcode = el.querySelector \.postertrip                ?.innerHTML
    &capcode  = el.querySelector \.capcode                   ?.innerHTML

    &email    = el.querySelector \.useremail ?.href.substring(7) # strip mailto:
    &sage     = sage-regex.test that if &email

    &comment = enhancer.enhance do
      el.querySelector \.postMessage .innerHTML

    &uid = el.querySelector \.hand ?.textContent # hand?

    &image = if img = el.querySelector \.fileThumb
      unless (&deletedImage = img.firstElementChild.alt is "File deleted.")
        thumb      = img.firstElementChild

        # use getAttribute because `href` property adds the protocol, while
        # getAttribute returns the protocolless //version (the text of the
        # actual html attribute)
        url        = img.getAttribute \href
        timestamp  = url.match /\/(\d+)/ .1

        info       = el.querySelector \.fileInfo .innerHTML
        dimensions = dimension-regex.exec info

        thumb:
          # since thumb's href is spoiler sometimes, recalc
          # FIXME doesn't work for crossboard fetches
          url    : "//thumbs.4chan.org/#{board.name}/thumb/#{timestamp}s.jpg"
          width  : parseInt thumb.style.width, 10
          height : parseInt thumb.style.height, 10

        url      : url

        width    : parseInt dimensions.1, 10
        height   : parseInt dimensions.2, 10

        size     : size-regex.exec thumb.alt .0
        filename : filename-regex.exec(info)?1
        md5      : thumb.dataset.md5

        spoiler  : spoiler-regex.test thumb.alt

    &postprocess!

# TODO clean up this code
module.exports =
  # returns Array of threads
  board: (document) ->
    console.time "parse board"
    threads = Array::map.call do
      document.querySelectorAll \.thread
      parse-thread
    console.timeEnd "parse board"

    return threads

  thread: (document) ->
    console.time "parse thread"
    thread = parse-thread document.querySelector \.thread
    console.timeEnd "parse thread"

    return thread

  # transform API thread format to the data used here. Returns Thread.
  api: ({posts: [op]}: data) -> new Thread
    &no  = op.no
    &url = board.threadurl + op.no

    &preview = !!op.omitted_posts
    &sticky  = !!op.sticky
    &closed  = !!op.closed

    &[\op ...\replies] = data.posts.map parse-api-post, &

    &postprocess!

# TODO cross-board linking will break this
thumbs-base = "//thumbs.4chan.org/#{board.name}/thumb/"
images-base = "//images.4chan.org/#{board.name}/src/"

humanized = (bytes) ->
  if bytes < 1024
    "#bytes B"
  else if (kbytes = Math.round bytes / 1024) < 1024
    "#kbytes KB"
  else
    "#{(kbytes / 1024)toString!substring 0 3} MB"

# "this" is thread
parse-api-post = (data, i) -> new Post
  &idx      = i
  &thread   = this
  &url      = "#{@url}##{data.no}"
  &time     = new Date data.time * 1000
  & <<< data{
    no
    subject: sub
    name
    tripcode: trip
    uid: id
    capcode
    email
  }
  &sage     = &email is \sage
  &comment  = if data.com then enhancer.enhance that else ''
  &image    = if data.fsize
    thumb:
     url    : thumbs-base + data.tim + \s.jpg
     width  : data.tn_w
     height : data.tn_h

    url      : "#{images-base}#{data.tim}#{data.ext}"

    width    : data.w
    height   : data.h

    size     : humanized data.fsize
    filename : "#{data.filename}#{data.ext}"
    md5      : data.md5

    spoiler  : !!data.spoiler

  &deleted-image = !!data.filedeleted

  &postprocess!

