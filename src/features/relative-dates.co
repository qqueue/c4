# update relative post dates periodically

# each time element adds a function to update itself to the stale list once it
# becomes inaccurate.  the stale list is flushed and stale times are updated
# whenever the DOM changes otherwise, which keeps the times as up to date as
# possible without incurring separate DOM reflows.
stale = []

debounce-leading = (delay, fn) ->
  var timeout
  reset = !-> timeout := null
  -> unless timeout
    fn ...
    timeout := defer delay, reset

flush = debounce-leading SECOND, !->
  now = Date.now!
  for stale => & now
  stale.length = 0

  periodic.restart!

# flush even in absence of other reflows
periodic = repeat MINUTE, {-auto} flush

keep-up-to-date = !(el) ->
  time = new Date(el.getAttribute \datetime)

  update = !(now) ->
    el.textContent = time.relative-date now
    make-timeout now - time.getTime!

  add-to-stale = !-> stale.push update

  make-timeout = !(diff) ->
    # calculate when relative date will be stale again
    delay = if diff < MINUTE
      diff % SECOND
    else if diff < HOUR
      diff % MINUTE
    else if diff < DAY
      diff % HOUR
    else if diff < MONTH
      diff % DAY
    else if diff < YEAR
      diff % MONTH
    else
      diff % YEAR
    defer delay, add-to-stale

  make-timeout Date.now! - time.getTime!

onpostinsert !->
  keep-up-to-date it.detail.post.querySelector \time

  # take advantage of DOM reflow
  flush!

# flush when user switches back to the tab
window.addEventListener \visibilitystatechange !->
  flush! unless document.hidden

onready -> periodic.start!

