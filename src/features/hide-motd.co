# MOTD functionality ot free up vertical space after it's been read
# TODO s/MOTD/globalMessage/ for less 4chan naming friction
#
# Concerns:
#
# - Toggle message display with a button
#   - Toggle button text should reflect display state
# - Persist message display state between sessions
# - Show _new_ messages regardless of previous message display state

# bacon.js-alike implementation, for kicks, until browserification
class Observable
  ->
    @callbacks = []

  emit: (event) ->
    for @callbacks
      & event

  # onValue in bacon, but each makes more sense with `map` and others, and is
  # more like clojure's `doseq`
  each: -> @callbacks.push it

  map: (fn) ->
    with new EventStream
      @each -> &emit it

  scan: (seed, reduce) ->
    with new Property seed
      @each -> &change reduce &value, it

class EventStream extends Observable
  -> super ...

  ..from-events = (el, event) ->
    with new EventStream
      el.addEventListener event, &~emit

class Property extends Observable
  (@value) ->
    super ...

  # TODO could use setter, I suppose
  change: (val) ->
    @value = val
    @emit val

  assign: (obj, property) ->
    asn = -> obj[property] = it
    @each asn

    # initialize if necessary
    asn that if @value?

<-! onready

if $ \motd
  button  = $ \hide-motd
  message = $ \message

  # toggle concern
  message-hidden = EventStream.from-events button, \click
    .scan false, -> not it

  message-hidden.assign message, \hidden

  # button text concern
  message-hidden
    .map -> "#{if it then "Show" else "Hide"} News"
    .assign button \textContent

  # persistence concern

  # FIXME dunno how to properly do this reactively
  message.hidden = get \motd-hidden

  message-hidden.assign get, \motd-hidden

  # show _new_ messages concern

  # unlikely to be 2 consecutive messages with the same length, so cheat
  hash = -> it.innerHTML.length

  previous = get \motd-hash

  # XXX not that reactive
  if hash message is not previous
    message.hidden = false
    set \motd-hash hash message

