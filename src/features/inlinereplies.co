# inline replies
# with lots of delicious messy logic to ensure
# mouse position is maintained

# scroll! returns to the scroll position when
# markScroll! was last called
{markScroll, scroll} = let
  var last, el
  markScroll: ->
    el := it
    last := el.getBoundingClientRect!top
  scroll: ->
    window.scrollBy 0, el.getBoundingClientRect!top - last

onclick = !(e) ->
  return if e.altKey or e.ctrlKey or e.shiftKey or e.metaKey
  return unless post = Post[id = @hash.substring 2]
  e.preventDefault!

  host = closest \.post, this .id
  hostid = (host / \-)pop! # grab last (if nested inline post)
  inlined_id = "#{host}-p#id" # id is unique to hosting post and inlined post
  stub_id = "#{id}-inlined-stub"

  if inlined = $ inlined_id # toggle off

    markScroll this

    @classList.remove \inlinedlink
    @parentNode.classList.remove \inlinedquote

    # remove original post's inlined status if this is the last inlining
    # link
    if $$ ".inline[data-id=\"#id\"]" .length is 1
      $ "p#id" ?.classList.remove \inlined

    # and for nested posts
    for inlined.querySelectorAll '.post.inline'
      pid = (&id / \-)pop!
      if $$ ".inline[data-id=\"#pid\"]" .length is 1
        $ "p#pid" ?.classList.remove \inlined

    inlined.remove!

    scroll!

  else # create
    inlined = post.element \article "inline hovered" inlined_id
    # walk outside of inline elements like spoilers and greentext
    wrapper = this
    while wrapper.parentElement.matchesSelector 'a,span,p'
      wrapper.=parentElement

    markScroll this

    # insert post in "natural" reading order
    wrapper[if @classList.contains \backlink then \after else \before] inlined

    document.dispatchEvent new CustomEvent do
      \html5chan-postinsert
      detail: {post: inlined}

    # replace matching reply links
    # done after postinsert so quote-replies will work
    for inlined.querySelectorAll "a.quotelink[href$=\"#hostid\"]"
      &className = \recursivelink
      &removeAttribute \href

    # remove unecessary first quote (implied by nesting
    inlined.querySelector \.comment ?.firstElementChild?firstElementChild
      if &?firstElementChild?className is \recursivelink
        &nextSibling?remove! # the <br>
        &remove!

    @classList.add \inlinedlink
    @parentNode.classList.add \inlinedquote

    $ \postpreview ?.remove!

    $ "p#id" ?.classList.add \inlined

    scroll!


follow = !->
  window.location.hash = that if @hash # actually follow link

onready !->
  for $$ '.quotelink:not(.hiddenlink)'
    &addEventListener \click onclick
    &addEventListener \dblclick follow

onpostinsert !->
  for it.detail.post.querySelectorAll '.quotelink:not(.hiddenlink)'
    &addEventListener \click onclick
    &addEventListener \dblclick follow

onbacklink !({detail}) ->
  <-! defer 100ms
  detail.post.querySelector ".backlink[href$=p#{detail.id}]"
    &addEventListener \click onclick
    &addEventListener \dblclick follow
