# TODO add check to constrain image to the quandrant around the mouse
# that has the greatest area, so a catalog-like layout is possible
constrain = (el, {clientX: x, clientY: y}) ->
	# why use getAttribute instead of width and height directly?
	# width and height are affected by css styles, while getAttribute
	# returns the value first set on the element
	width = el.getAttribute \width
	height = el.getAttribute \height
	docheight = window.innerHeight - 20
	availableheight = docheight - y
	# using clientWidth to account for scrollbars
	# can't use it for height because it would be the entire
	# document height
	docwidth = document.documentElement.clientWidth - 20
	availablewidth = docwidth - x
	
	ratio = Math.min 1, docheight/height, availablewidth/width

	el.style.width = width * ratio
	el.style.height = height * ratio

	el.style.left = x + 10
	if (height * ratio ) > availableheight
		el.style.bottom = 10
		el.style.removeProperty \top
	else
		el.style.top = y + 10

make = (e) ->
	width = @parentElement.getAttribute \data-width
	height = @parentElement.getAttribute \data-height

	remove document.getElementById \imgpreview

	document.body.appendChild do
		kup \img {id: \imgpreview, src: @parentElement.href, alt: "Loading...", width, height } ->
			@on \load ->
				@removeAttribute \alt
				@style.opacity = 1
			@on \error -> @alt = "Unable to load image."

			constrain this, e

			@style.opacity = 0.7
			@style.position = \fixed
	listen this
		.on \mousemove move

move = (e) -> 
	constrain document.getElementById(\imgpreview), e

destroy = (e) ->
	remove document.getElementById \imgpreview
	listen this
		.off \mousemove move

# image hover previews
features.imgpreviews = 
	on: ->
		listen document.getElementById \threads
			.on \mouseenter 'img.thumb' make
			.on \mouseleave 'img.thumb' destroy
	off: ->
		listen document.getElementById \threads
			.off \mouseenter make
			.off \mouseleave destroy
