# problem: it's hard to tell which posts or threads haven't been seen before.
#
# solution: keep track oh unread posts and threads and style unread ones
# differently.

{get, set, sset, sget} = require \../utils/storage
{onready, onpostinsert} = require \../utils/features
{$, $$} = require \../utils/dom
{debounce, defer} = require \../utils/timing

# TODO threshold sticky posts or other posts that will stick around longer.
const threshold = 604800000ms # one week

read = get \read or {}

# clean out delete expired entries to keep object small
let now = Date.now!
  for no, expiry in read
    delete hash[key] if (now - expiry) > threshold

# keep track of unread posts on the current page
unread = []

onready !->
  # mark all unread posts.
  # don't read posts that are visible immediately, to give some indication of
  # which posts on the current view are still unread.
  visible = []
  page-bottom = window.scrollY + window.innerHeight
  for $$ \.post
    if not read[&dataset.no]
      &classList.add \unread
      if &getBoundingClientRect!bottom > page-bottom
        unread.push &
      else
        # mark as read in a view seconds
        visible.push &

  # then visiblize them
  defer 2000ms !->
    now = Date.now!
    page-bottom = window.scrollY + window.innerHeight
    for visible =>
      # if still visible
      if &getBoundingClientRect!bottom > page-bottom
        &classList.remove \unread
        read[&dataset.no] = now
      else
        # add to 'real' unread list
        unread.push &

  # mark as read once scrolled past
  # hopefully won't use too much CPU and make scrolling janky
  window.addEventListener \scroll debounce 1000ms !->
    page-bottom = window.scrollY + window.innerHeight
    still-unread = []

    # TODO could probably speed this up by relying on post ordering.
    for unread
      bot = &getBoundingClientRect!bottom
      if bot < page-bottom
        &classList.remove \unread
        read[&dataset.no] = Date.now!
      else
        still-unread.push &
    unread := still-unread

  window.addEventListener \unload !->
    # since other tabs could have changed this in the interim time, merge with
    # current localStorage version
    set \read {...read, ...get \read}

onpostinsert !->
  # two possible cases: new updated post, or inlined/previews post
  if @post.classList.contains \new
    # TODO get rid of 'new' class somehow
    unread.push @post
    @post.classList.add \unread
  else
    # find original post and mark as read
    $ "p#{@post.dataset.no}"
      &classList.remove \unread
      if (idx = unread.indexOf(&)) >= 0
        unread.splice idx, 1
      unless read[&dataset.no]
        read[&dataset.no] = Date.now!

