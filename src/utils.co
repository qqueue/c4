# various utils
# these aren't wrapped, so they are available
# everywhere else
# TODO namespace these to avoid embarrasing collisions

# had to resort to lame hack
# I would monkey-patch Element.prototype,
# but scriptish/Greasemonkey don't expose the real
# prototype, so DOM patching is impossible ;_;
matchesSelector = if document.head
	\mozMatchesSelector
else
	\webkitMatchesSelector

# special prefixed getters and setters

# though honestly, I think greasemonkey wraps storage
# so there's no chance of collisions anyway
sset = -> sessionStorage.setItem "html5chan-#key", val for key, val in it
sget = -> sessionStorage.getItem "html5chan-#it"
set = -> localStorage.setItem "html5chan-#key" val for key, val in it
get = -> localStorage.getItem "html5chan-#it"

create = (tag, fn) -> # helper method to avoid temporary variables with createElement
	el = document.createElement tag
	fn.call el, el # el is also the first argument, in case 'this' is unusable
	el

render_all = (objects, ...options) ->
	(obj.render.apply obj, options for obj of objects).join ''

# TODO compact delegated listeners
# by checking some sort of list of listeners
# on the same parent with the same event type
# so when walking up the tree, we can check all
# selectors
mouse = mouseenter: \mouseover, mouseleave: \mouseout
listen = (element) -> new # chainable wrapper for addEventListener
		@on = (event, selector, handler) ->
			return this unless element
			if (events = event.split ' ').length > 1 # handle space separated events
				@on e, selector, handler for e of events
				return
			if typeof selector is \function
				handler = selector
				selector = null
			# replace non-bubbling events with those that do
			event = that if mouse[event]
			element.addEventListener do
				event
				if selector then !({target}: event) ->
					return unless target # sometimes target disappears, weird
					# if actual selector, or child of selector
					# this offloads the usual strategy of walking up parentElements
					# to the internal browser query engine
					if target[matchesSelector] "#selector, #selector *" 
						# still need to walk up tree to find target context
						target.=parentElement until target[matchesSelector] selector
						if handler.call(target, event) is false
							log "canceling propogation"
							event.stopPropagation!
							event.preventDefault!
						return 
				else handler # just plain callback
			return this
		# TODO this doesn't handle delegated events very well
		@off = (event, handler) ->
			return this unless element
			if (events = event.split ' ').length > 1 # handle space separated events
				@off e, handler for e of events
				return
			element.removeEventListener event, handler

closest = (selector, el) ->
	return false unless el
	until el!?, el.=parentElement
		return el if el[matchesSelector] selector
remove = -> it.parentElement.removeChild it if it and it.parentElement


do ->
	pad = (number) ->
		str = number.toString()
		return if str.length < 2 then "0"+str else str; # pad to 2 digits
	Date::prettyPrint = ->
		return @getFullYear()+"-"+pad(@getMonth()+1)+"-"+pad(@getDate())+" "+pad(@getHours())+":"+pad(@getMinutes())
	Date::prettyRelative = ->
		if (days = (new Date().getTime! - @getTime!) / 86400000) > 30
			@prettyPrint! # just give absolute time
		else if days > 1
			"#{Math.ceil days} days ago"
		else if (hours = days * 24) >= 1
			"#{h = Math.round hours} hour#{if h > 1 then \s else ''} ago"
		else if (minutes = hours * 60) > 1
			"#{Math.ceil minutes} minutes ago"
		else
			"Less than a minute ago"

# coffeekup-like dom builder
# pretty fuckin magical
kup = do ->
	class ElementProxy
		(parent, tag, attributes, content) ->
			@dom = document.createElement tag
			parent.dom.appendChild @dom if parent
			unless typeof attributes is \object
				content = attributes
				attributes = {}
			@dom <<< attributes
			if content?
				if typeof content is \function
					content.call this
				else
					@dom.textContent = content
		tag: (tag, attributes, content) -> new ElementProxy this, tag, attributes, content

		# proxy common attributes, non-exhaustive
		for attr of <[id classList src href style width height]>
			let then Object.defineProperty ElementProxy.prototype, attr,
					get: -> @dom[attr]
					set: -> @dom[attr] = it

		# helpers for each kind of element
		# non-exhaustive, until I need them
		for tag of <[body div section header footer article hgroup h1 h2 a ol ul li span b i em strong]>
			let then ElementProxy::[tag] = (attributes, content) ->
					new ElementProxy this, tag, attributes, content
	
	(tag, attributes, content) ->
		el = new ElementProxy void, tag, attributes, content
		return el.dom

