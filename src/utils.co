# various utils
# these aren't wrapped, so they are available
# everywhere else

# I'll take the tiny performance hit for nicer method names, except in the parser
$ = -> document.getElementById it
$$ = -> document.querySelectorAll it

# polyfills and monkey patches
Element::matchesSelector ?=
  Element::mozMatchesSelector or Element::webkitMatchesSelector

# DOM4 mutation methods
do ->
  mutation-macro = (nodes) ->
    return nodes.0 if nodes.length > 0

    node = document.createDocumentFragment!

    for n of nodes
      if typeof n is \string
        n = document.createTextNode n
      node.appendChild n

    return node

  Node::
    &prepend ?= !->
      @insertBefore do
        mutation-macro @@
        @firstChild

    &append ?= !->
      @appendChild mutation-macro @@

    &before ?= !->
      return unless @parentNode
      @parentNode.insertBefore do
        mutation-macro @@
        this

    &after ?= !->
      return unless @parentNode
      @parentNode.insertBefore do
        mutation-macro @@
        @nextSibling

    &replace ?= !->
      return unless @parentNode
      @parentNode.replaceChild do
        mutation-macro @@
        this

    &remove ?= !->
      return unless @parentNode
      @parentNode.removeChild this

# special prefixed getters and setters
# to avoid a possible collision with other userscripts
# uses the nice property that JSON.stringify(string) is still reversible with
# JSON.parse, since it adds the necessary double quotes
[set, get, sset, sget] = do ->
  setter = (storage) -> !(key, val) ->
    obj = (key): val if val # support both hash and key,val syntax
    for key, val in obj or key
      storage.setItem "html5chan-#key", JSON.stringify val
  getter = (storage) -> -> try JSON.parse storage.getItem "html5chan-#it"

  return
    setter localStorage
    getter localStorage
    setter sessionStorage
    getter sessionStorage

render_all = (objects, ...options) ->
  (obj.render.apply obj, options for obj of objects).join ''

# A parallel array polyfill of ES6 Map
# O(n) access time, so don't use extensively
window.Map ?= class
  ->
    @keys = []
    @values = []

  get: (key) -> @values[find key, @keys]

  set: !(key, val) ->
    if (idx = find key, @keys) is not -1
      @values[idx] = val
    else
      @keys.push key
      @values.push val

  has: (key) -> find(key, @keys) is not -1

  delete: !(key) ->
    if (idx = find key, @keys) is not -1
      @keys.splice idx, 1
      @values.splice idx, 1
      return true
    else
      return false

  size: -> @keys.length

  # strict equality version of indexOf
  find = (key, keys) ->
    for k, i of keys
      return i if Object.is k, key
    return -1

# chainable, delegatable wrapper for addEventListener
# Lots of logic to keep references to delegated versions of handlers. At some
# point, I'll have to look at how jQuery keeps track of those things, and see
# how my version compares
class Listener
  (@element) ->

  on: (event, selector, handler) ->
    return this unless @element

    # handle space separated events
    if (events = event / ' ')length > 1
      @on e, selector, handler for e of events
      return this

    # "selector" argument is optional
    if typeof selector is \function
      handler = selector
      selector = null

    if selector
      delegated-handler = !({target}: event) ->
        return unless target
        if target.matchesSelector "#selector, #selector *"
          # find delegated target
          target.=parentElement until target.matchesSelector selector

          handler.call target, event

      if delegated-elements.has @element
        delegated-handlers = delegated-elements.get @element
      else
        delegated-handlers = {}
        delegated-elements.set @element, delegated-handlers

      delegated-handlers[selector] ?= new Map
        &set handler, delegated-handler

    @element.addEventListener event, delegated-handler || handler

    return this

  off: (event, selector, handler) ->
    return this unless @element

    if (events = event / ' ')length > 1 # handle space separated events
      @off e, handler for e of events
      return

    # "selector" argument is optional
    if typeof selector is \function
      handler = selector
      selector = null

    # find delegated handler
    if selector
      # if delegated handler was never added
      return unless delegated-elements.has @element

      delegated-handlers = delegated-elements.get @element

      if delegated-handlers[selector]?get handler
        delegated-handler = that
        delegated-handlers[selector]delete handler

        # clean up references
        if delegated-handlers[selector].size() is 0
          delete delegated-handlers[selector]
          if Object.keys(delegated-handlers).length is 0
            delegated-elements.delete @element
      else
        return

    @element.removeEventListener event, delegated-handler || handler

    return this

  # to avoid using expando properties on elements to store their delegated
  # listeners, this global map stores the association
  delegated-elements = new Map

listen = -> new Listener it

closest = (selector, el) ->
  while el, el.=parentElement
    return el if el.matchesSelector selector

do ->
  pluralize = (number, unit) ->
    "#{Math.round number} #unit#{if number >= 1.5 then \s else ''} ago"

  Date::relative_time = ->
    if ( days = ( ( diff = Date.now! - @getTime! ) / 86400000 ) ) > 1
      pluralize days, \day
    else if ( hours = days * 24 ) > 1
      pluralize hours, \hour
    else if ( minutes = hours * 60 ) > 1
      pluralize minutes, \minute
    else if ( seconds = minutes * 60 ) >= 1
      pluralize seconds, \second
    else
      'from the future!'

# coffeekup-like dom builder
# pretty fuckin magical
kup = do ->
  class ElementProxy
    (parent, tag, attributes, content) ->
      # lots of fancy optional argument logic, thanks javascript
      # TODO document this shit
      @el = if typeof tag is \string
        document.createElement tag
      else # no tag specified, so shift arguments backwards
        attributes = tag
        content = attributes
        document.createDocumentFragment!
      parent.el.appendChild @el if parent
      # handle either extended attributes,
      # or a string of text
      if typeof attributes is \string
        @el.textContent = attributes
      else if typeof attributes is \object
        @el <<< attributes
      else
        content = attributes
      if content?
        if typeof content is \function
          content.call this
        else
          @el.textContent = content


    tag: (tag, attributes, content) ->
      new ElementProxy this, tag, attributes, content

    # delegated to listen()
    on: (event, selector, handler) ->
      listen @el .on event, selector, handler
    off: (event, selector, handler) ->
      listen @el .off event, selector, handler

    # simple property copy for css
    css: -> @el.style <<< it

    # proxy common attributes, non-exhaustive
    <[
      id classList src href style width height textContent naturalWidth
      naturalHeight attributes
    ]>forEach (attr) ->
      Object.defineProperty ElementProxy.prototype, attr,
        get: -> @el[attr]
        set: -> @el[attr] = it

    # proxy common methods
    <[
      getAttribute
    ]>forEach (method) ->
      ElementProxy::[method] = -> @el[method].apply @el, @@

    # helpers for each kind of element
    # non-exhaustive, until I need them
    <[
      body div section header footer article hgroup h1 h2 a ol ul li span
      b i em strong img
    ]>forEach (tag) ->
      ElementProxy::[tag] = (attributes, content) ->
        new ElementProxy this, tag, attributes, content

  (tag, attributes, content) ->
    new ElementProxy void, tag, attributes, content .el

truncate = (it, length = 20) ->
  if it.length > length then "#{it.substring 0 length}..." else it

debounce = (delay, fn) ->
  var timeout
  !->
    ctx = this
    args = arguments
    clearTimeout timeout
    timeout := setTimeout do
      !-> fn.apply ctx, args
      delay

