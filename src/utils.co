$.fn.extend do
	immediateText: -> 
		@parent().clone().children().remove().end().text()
	
	exists: (selector) -> 
		( if selector then @find selector else this ).length > 0
	
	changeTo: (replacement, options) -> 
		@replaceWith ->
			$(replacement,options).html($(this).html())

	constrainY: ({left, top}, margin = 0) ->
		height = @height() 
		bottom = top + height
		screentop = $(window).scrollTop()
		screenbottom = screentop + $(window).height()
		
		if bottom > screenbottom
			top = screenbottom - margin - height
			
		if top < screentop
			top = screentop + margin
			
		@css do
			left: left
			top: top
			position: "absolute"
			
	beforeAndScroll: (content) ->
		before = @offset()
		@before content
		after = @offset()
		window.scrollBy after.left - before.left, after.top - before.top 
		return this
		
	removeAndScroll: (relativeTo) ->
		before = relativeTo.offset()
		@remove()
		after = relativeTo.offset()
		# unless the scrollbar is already at the bottom (which autocorrects position)
		unless window.scrollY is window.scrollMaxY
			window.scrollBy after.left - before.left, after.top - before.top
		return this

# special prefixed getters and setters
# though honestly, I think greasemonkey wraps storage
# so there's no chance of collisions anyway
sset = -> sessionStorage.setItem "html5chan-#key", val for key, val in it
sget = -> sessionStorage.getItem "html5chan-#it"
set = -> localStorage.setItem "html5chan-#key" val for key, val in it
get = -> localStorage.getItem "html5chan-#it"

create = (tag, fn) -> # helper method to avoid temporary variables with createElement
	el = document.createElement tag
	fn.call el
	el

render_all = (objects, ...options) ->
	(obj.render.apply obj, options for obj of objects).join ''


listen = do ->
	(element) -> new # chainable wrapper for addEventListener
		@on = (event, selector, handler) ->
			if (events = event.split ' ').length > 1 # handle space separated events
				@on e, selector, handler for e of events
				return
			if typeof selector is \function
				handler = selector
				selector = null
			switch event
			case <[mouseenter mouseleave]>
				useCapture = true # since they don't bubble
				exact_match = true # since children will fire mouseenter too
			element.addEventListener do
				event
				if selector then !({target}: event) ->
					do # walk up tree to find matches
						if target.mozMatchesSelector selector
							if handler.call(target, event) is false
								event.stopPropagation!
								event.preventDefault!
							return 
						target.=parentElement 
					until target is element or exact_match
				else handler # just plain callback
				useCapture
			return this



		


