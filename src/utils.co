# various utils
# these aren't wrapped, so they are available
# everywhere else
# TODO namespace these to avoid embarrasing collisions

# I'll take the tiny performance hit, except in the parser
$ = -> document.getElementById it
$$ = -> document.querySelectorAll it

# had to resort to lame hack
# I would monkey-patch Element.prototype,
# but scriptish/Greasemonkey don't expose the real
# prototype, so DOM patching is impossible ;_;
matchesSelector = unless Element.prototype
	\mozMatchesSelector
else
	\webkitMatchesSelector

# special prefixed getters and setters
# to avoid a possible collision with other userscripts
sset = (key, val) -> 
	obj = (key): val if val
	for key, val in obj or key
		sessionStorage.setItem "html5chan-#key", if typeof val is \string then val else JSON.stringify val
sget = -> 
	try
		JSON.parse sessionStorage.getItem "html5chan-#it"
	catch
		sessionStorage.getItem "html5chan-#it"

set = (key, val) -> 
	obj = (key): val if val
	for key, val in obj or key
		localStorage.setItem "html5chan-#key", if typeof val is \string then val else JSON.stringify val
get = -> 
	try
		JSON.parse localStorage.getItem "html5chan-#it"
	catch
		localStorage.getItem "html5chan-#it"

create = (tag, fn) -> # helper method to avoid temporary variables with createElement
	el = document.createElement tag
	fn.call el, el # el is also the first argument, in case 'this' is unusable
	el

render_all = (objects, ...options) ->
	(obj.render.apply obj, options for obj of objects).join ''

# TODO compact delegated listeners
# by checking some sort of list of listeners
# on the same parent with the same event type
# so when walking up the tree, we can check all
# selectors
mouse = mouseenter: \mouseover, mouseleave: \mouseout
listen = (element) -> new # chainable wrapper for addEventListener
	@on = (event, selector, handler) ->
		return this unless element
		if (events = event.split ' ').length > 1 # handle space separated events
			@on e, selector, handler for e of events
			return
		if typeof selector is \function
			handler = selector
			selector = null
		# replace non-bubbling events with those that do
		event = that if mouse[event]
		element.addEventListener do
			event
			if selector then !({target}: event) ->
				return unless target # sometimes target disappears, weird
				# if actual selector, or child of selector
				# this offloads the usual strategy of walking up parentElements
				# to the internal browser query engine
				if target[matchesSelector] "#selector, #selector *" 
					# still need to walk up tree to find target context
					target.=parentElement until target[matchesSelector] selector
					if handler.call(target, event) is false
						event.stopPropagation!
						event.preventDefault!
					return 
			# TODO add same wrapper for return false
			else handler # just plain callback
		return this
	# TODO this doesn't handle delegated events very well
	@off = (event, handler) ->
		return this unless element
		if (events = event.split ' ').length > 1 # handle space separated events
			@off e, handler for e of events
			return
		element.removeEventListener event, handler
		return this

closest = (selector, el) ->
	return false unless el
	while el, el.=parentElement
		return el if el[matchesSelector] selector
remove = -> it.parentElement.removeChild it if it and it.parentElement


do ->
	pad = (number) ->
		str = number.toString()
		return if str.length < 2 then "0"+str else str; # pad to 2 digits
	# TODO add day of week
	Date::prettyPrint = ->
		return @getFullYear()+"-"+pad(@getMonth()+1)+"-"+pad(@getDate())+" "+pad(@getHours())+":"+pad(@getMinutes())
	Date::prettyRelative = ->
		if (days = (new Date().getTime! - @getTime!) / 86400000) > 30
			@prettyPrint! # just give absolute time
		else if days > 1
			"#{Math.ceil days} days ago"
		else if (hours = days * 24) >= 1
			"#{h = Math.round hours} hour#{if h > 1 then \s else ''} ago"
		else if (minutes = hours * 60) > 1
			"#{Math.ceil minutes} minutes ago"
		else
			"Less than a minute ago"

# coffeekup-like dom builder
# pretty fuckin magical
kup = do ->
	class ElementProxy
		(parent, tag, attributes, content) ->
			# lots of fancy optional argument logic, thanks javascript
			# TODO document this shit
			@el = if typeof tag is \string
				document.createElement tag
			else # no tag specified, so shift arguments backwards
				attributes = tag
				content = attributes
				document.createDocumentFragment!
			parent.el.appendChild @el if parent
			# handle either extended attributes,
			# or a string of text
			if typeof attributes is \string
				@el.textContent = attributes
			else if typeof attributes is \object
				@el <<< attributes
			else
				content = attributes
			if content?
				if typeof content is \function
					content.call this
				else 
					@el.textContent = content

		
		tag: (tag, attributes, content) -> new ElementProxy this, tag, attributes, content

		# delegated to listen()
		on: (event, selector, handler) -> listen @el .on event, selector, handler
		off: (event, selector, handler) -> listen @el .off event, selector, handler

		# proxy common attributes, non-exhaustive
		<[
			id classList src href style width height textContent naturalWidth naturalHeight
			attributes
		]>.forEach (attr) ->
			Object.defineProperty ElementProxy.prototype, attr,
				get: -> @el[attr]
				set: -> @el[attr] = it
		# proxy common methods
		<[
			getAttribute
		]>.forEach (method) ->
			ElementProxy::[method] = -> @el[method].apply @el, @@

		# helpers for each kind of element
		# non-exhaustive, until I need them
		<[
			body div section header footer article hgroup h1 h2 a ol ul li span b i em strong
			img
		]>.forEach (tag) ->
			ElementProxy::[tag] = (attributes, content) ->
				new ElementProxy this, tag, attributes, content
	
	(tag, attributes, content) ->
		new ElementProxy void, tag, attributes, content .el

# note that the syntax of reference, then new element is backwards
# from Node.insertBefore. I think my syntax is more readable
insertBefore = (ref, el) -> ref.parentNode.insertBefore el, ref
insertAfter = (ref, el) -> insertBefore ref.nextSibling, el

# sha1 hasher, used for e{x|-}hentai sauce

truncate = (it, length = 20) -> 
	if it.length > length then "#{it.substring 0 length}..." else it

