# various utils
# these aren't wrapped, so they are available
# everywhere else

# special prefixed getters and setters
# though honestly, I think greasemonkey wraps storage
# so there's no chance of collisions anyway
sset = -> sessionStorage.setItem "html5chan-#key", val for key, val in it
sget = -> sessionStorage.getItem "html5chan-#it"
set = -> localStorage.setItem "html5chan-#key" val for key, val in it
get = -> localStorage.getItem "html5chan-#it"

create = (tag, fn) -> # helper method to avoid temporary variables with createElement
	el = document.createElement tag
	fn.call el, el # el is also the first argument, in case 'this' is unusable
	el

render_all = (objects, ...options) ->
	(obj.render.apply obj, options for obj of objects).join ''

# TODO compact delegated listeners
# by checking some sort of list of listeners
# on the same parent with the same event type
# so when walking up the tree, we can check all
# selectors
listen = (element) -> new # chainable wrapper for addEventListener
		@on = (event, selector, handler) ->
			return this unless element
			if (events = event.split ' ').length > 1 # handle space separated events
				@on e, selector, handler for e of events
				return
			if typeof selector is \function
				handler = selector
				selector = null
			switch event
			case <[mouseenter mouseleave]>
				useCapture = true # since they don't bubble
				exact_match = true # since children will fire mouseenter too
			element.addEventListener do
				event
				if selector then !({target}: event) ->
					return unless target # sometimes target disappears, weird
					do # walk up tree to find matches
						if target.mozMatchesSelector selector
							if handler.call(target, event) is false
								event.stopPropagation!
								event.preventDefault!
							return 
						target.=parentElement 
					until target is null or target is element or exact_match
				else handler # just plain callback
				useCapture
			return this
		@off = (event, handler) ->
			return this unless element
			if (events = event.split ' ').length > 1 # handle space separated events
				@off e, handler for e of events
				return
			switch event
			case <[mouseenter mouseleave]>
				useCapture = true # since they don't bubble
			element.removeEventListener event, handler, useCapture

closest = (selector, el) ->
	return false unless el
	until el!?, el.=parentElement
		return el if el.mozMatchesSelector selector
remove = -> it.parentElement.removeChild it if it and it.parentElement

removeAndScroll = (removed, relativeTo) ->
	[oldx,oldy] = [relativeTo.offsetLeft, relativeTo.offsetTop]
	remove removed
	[newx,newy] = [relativeTo.offsetLeft, relativeTo.offsetTop]
	unless window.scrollY is window.scrollMaxY
		window.scrollBy newx-oldx, newy-oldy

insertAndScroll = (inserted, relativeTo) ->
	[oldx,oldy] = [relativeTo.offsetLeft, relativeTo.offsetTop]
	relativeTo.parentElement.insertBefore inserted, relativeTo
	[newx,newy] = [relativeTo.offsetLeft, relativeTo.offsetTop]
	window.scrollBy newx-oldx, newy-oldy

do ->
	pad = (number) ->
		str = number.toString()
		return if str.length < 2 then "0"+str else str; # pad to 2 digits
	Date::prettyPrint = ->
		return @getFullYear()+"-"+pad(@getMonth()+1)+"-"+pad(@getDate())+" "+pad(@getHours())+":"+pad(@getMinutes())
	Date::prettyRelative = ->
		if (days = (new Date().getTime! - @getTime!) / 86400000) > 30
			@prettyPrint! # just give absolute time
		else if days > 1
			"#{Math.ceil days} days ago"
		else if (hours = days * 24) >= 1
			"#{h = Math.round hours} hour#{if h > 1 then \s else ''} ago"
		else if (minutes = hours * 60) > 1
			"#{Math.ceil minutes} minutes ago"
		else
			"Less than a minute ago"

