# special prefixed getters and setters
# though honestly, I think greasemonkey wraps storage
# so there's no chance of collisions anyway
sset = -> sessionStorage.setItem "html5chan-#key", val for key, val in it
sget = -> sessionStorage.getItem "html5chan-#it"
set = -> localStorage.setItem "html5chan-#key" val for key, val in it
get = -> localStorage.getItem "html5chan-#it"

create = (tag, fn) -> # helper method to avoid temporary variables with createElement
	el = document.createElement tag
	fn.call el
	el

render_all = (objects, ...options) ->
	(obj.render.apply obj, options for obj of objects).join ''

# TODO compact delegated listeners
# by checking some sort of list of listeners
# on the same parent with the same event type
# so when walking up the tree, we can check all
# selectors
listen = do ->
	(element) -> new # chainable wrapper for addEventListener
		@on = (event, selector, handler) ->
			if (events = event.split ' ').length > 1 # handle space separated events
				@on e, selector, handler for e of events
				return
			if typeof selector is \function
				handler = selector
				selector = null
			switch event
			case <[mouseenter mouseleave]>
				useCapture = true # since they don't bubble
				exact_match = true # since children will fire mouseenter too
			element.addEventListener do
				event
				if selector then !({target}: event) ->
					return unless target # sometimes target disappears, weird
					do # walk up tree to find matches
						if target.mozMatchesSelector selector
							if handler.call(target, event) is false
								event.stopPropagation!
								event.preventDefault!
							return 
						target.=parentElement 
					until target is null or target is element or exact_match
				else handler # just plain callback
				useCapture
			return this

closest = (selector, el) ->
	return false unless el
	until el!?, el.=parentElement
		return el if el.mozMatchesSelector selector
remove = -> it.parentElement.removeChild it if it and it.parentElement

removeAndScroll = (removed, relativeTo) ->
	[oldx,oldy] = [relativeTo.offsetLeft, relativeTo.offsetTop]
	remove removed
	[newx,newy] = [relativeTo.offsetLeft, relativeTo.offsetTop]
	unless window.scrollY is window.scrollMaxY
		window.scrollBy newx-oldx, newy-oldy

insertAndScroll = (inserted, relativeTo) ->
	[oldx,oldy] = [relativeTo.offsetLeft, relativeTo.offsetTop]
	relativeTo.parentElement.insertBefore inserted, relativeTo
	[newx,newy] = [relativeTo.offsetLeft, relativeTo.offsetTop]
	window.scrollBy newx-oldx, newy-oldy
