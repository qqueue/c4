last_update = new Date

updater.update = !->
  updater.status.textContent = "Updating thread..."
  updater.button.disabled = true

  new XMLHttpRequest
    &open \GET document.URL
    &responseType = \document

    &setRequestHeader \If-Modified-Since last_update.toUTCString!

    listen(&)
      .on \load !->
        if @status is 404
          titler.text += '(dead)'
          updater.status.textContent = "thread 404'd"
          return
        if @status is 304
          updater.countdown.restart!
          return

        last_modified = new Date @getResponseHeader \Last-Modified

        unless last_modified > last_update
          updater.countdown.restart!
          return

        updater.status.textContent = "update detected, parsing"
        last_update := last_modified

        thread = parser.thread @response
        if thread.new.length > 0
          $ "thread-#{thread.id}" .lastElementChild # .replies
            .insertAdjacentHTML do
              \beforeend
              render_all thread.new, \article, 'new reply'

          # refresh backlinks
          # TODO refactor out all the various places backlinks are made
          # into something less coupled
          for backlinks of $$ '.thread .backlinks'
            backlinks.insertAdjacentHTML do
              \beforeend
              Post[(backlinks.parentNode.id / \-)pop!]backlinks true

          # call after_update hooks
          fn! for fn of updater.callbacks

          # update title
          titler.number += thread.new.length

          # add scroll handler to rest number and new posts
          # when the window scrolls past the end of them
          resetNew thread.new

          if (window.scrollMaxY - window.scrollY) < 50 and not document.hidden
            # smooth scroll to the bottom, but if user scrolls upwards
            # manually, abort.
            let last = window.scrollY
              repeat 50ms {-auto} !->
                if last > window.scrollY
                  @stop!
                else if window.scrollMaxY - window.scrollY
                  window.scrollBy 0, that/4 >? 1
                  last := window.scrollY
                  @repeat!

          # update post count
          $ "thread-#{thread.id}" .querySelector ".thread-info" .textContent =
            "#{thread.replies.length} replies \
             and #{thread.imageReplies.length} image replies."

        updater.countdown.restart!

      .on \timeout !->
        updater.status.textContent = "request timed out..."
        updater.countdown!

      .on \error !-> updater.status.textContent = "Couldn't fetch thread page!"

      .on \loadend !-> updater.button.disabled = false

    &send!

# some spaghetti to remove the new class from posts
# once they are visible to the user
resetNew = !(posts) ->
  posts.forEach !(post) ->
    post = $ post.id

    removeNew = !->
      post.classList.remove \new
      --titler.number

    y = post.offsetTop

    if (window.innerHeight + window.scrollY) > y
      if document.hidden
        # fade them once the window is focused again
        listen window .once \focus !->
          # running immediately seems to break fade animation, thus setTimeout
          defer 100ms removeNew
      else
        removeNew!
    else
      # wait till post is scrolled to
      listen window .on \scroll function reset
        if ( window.innerHeight + window.scrollY ) > post.offsetTop
          removeNew!
          listen window .off \scroll reset

updater.callbacks = []

updater.after_update = !-> updater.callbacks.push it

updater.countdown = repeat 1000ms {-start} !(t) ->
  @t = t or @t or 30sec

  updater.status.textContent = "Updating in #{@t} seconds..."

  if --@t is 0
    @stop!
    updater.update!

onready !->
  updater.status = $ \update-status
  updater.button = $ \update-now

  # autoupdate threads
  if board.isThread
    updater.countdown.start!
    listen $ \update-now .on \click ->
      updater.countdown
        &stop!
        &t = 30ms
      updater.update!
  else
    $ \updater .hidden = true

