# Keep threads up to date
#
# - append new posts as they are made
# - detect when new posts are read
#   - keep an unread counter in the favicon
# - allow the user to manually request an update
#
# TODO this code _deperately_ needs FRP or promises or some shit. 190 LOC is
# way too much.

listen = require \./utils/listen
{onready} = require \./utils/features
{defer, repeat} = require \./utils/timing
{$, $$, L} = require \./utils/dom
post-template = require \templates/post
parser = require \./parser
draw-favicon = require \./utils/favicon

export updater = {}

# increase polling time when there are no new posts
const delays    = [10 15 20 30 60 90 120 180 240 300]
      max-delay = delays.length - 1

# state
current-delay = 0 # index into delay
last-update   = new Date
unread        = 0

!function append-new-posts thread, new-posts, deleted
  $ "t#{thread.no}" .lastElementChild # .replies
    .insertAdjacentHTML do
      \beforeend
      for new-posts
        post-template &, container: \article classes: 'new reply'
      .join ''

  for new-posts
    # XXX update global post hash. still not great global state
    board.posts[&no] = &
    document.dispatchEvent new CustomEvent do
      \html5chan-postinsert
      detail: post: $ "p#{&no}"

!function update-favicon thread, new-posts, deleted
  unread += new-posts.length
  draw-favicon board.favicon, if unread > 0 then "#unread" else ''

!function read-posts-when-scrolled-to thread, new-posts, deleted
  for new-posts => fade-when-visible &

!function update-thread-stats thread, new-posts, deleted
  $ "t#{thread.no}" .querySelector ".thread-info" .textContent =
    "#{thread.replies.length} replies \
     and #{thread.imageReplies.length} image replies."

# TODO update event should govern above features too
!function dispatch-update-event thread, new-posts, deleted
  document.dispatchEvent new CustomEvent do
    \html5chan-update
    detail: {thread}

!function smooth-scroll-to-bottom
  last = window.scrollY
  repeat 50ms !->
    #if user scrolls upwards manually, abort.
    if window.scrollY < last
      @stop!
    else if (remaining = window.scrollMaxY - window.scrollY) > 1
      window.scrollBy 0, 1 >? remaining / 4
      last := window.scrollY
    else
      @stop!

!function handle-new-posts thread, new-posts, deleted
  updater.status.textContent = "update detected, parsing"

  # if at the bottom of the page before adding new posts, smooth-scroll later
  if (window.scrollMaxY - window.scrollY) < 5 and not document.hidden
    scroll = true

  append-new-posts            thread, new-posts, deleted
  update-thread-stats         thread, new-posts, deleted
  update-favicon              thread, new-posts, deleted

  dispatch-update-event       thread, new-posts, deleted

  read-posts-when-scrolled-to thread, new-posts, deleted

  # if on the bottom of the page
  smooth-scroll-to-bottom! if scroll

!function disable-updater
  updater.countdown.stop!

!function reset-delay
  current-delay := 0

!function increase-delay
  current-delay := (current-delay + 1) <? max-delay

!function restart-countdown
  updater.tminus = delays[current-delay]
  updater.countdown.restart!

updater.update = !->
  # TODO factor out status text side effect
  updater.status.textContent = "Updating thread..."
  updater.button.disabled = true

  new XMLHttpRequest
    &open \GET "//api.4chan.org/#{board.name}/res/#{board.thread.no}.json"
    &setRequestHeader \If-Modified-Since last-update.toUTCString!
    &onload = !->
      if @status is 404
        document.title += '(dead)'
        updater.status.textContent = "thread 404'd"
        disable-updater!
      else
        last-modified = new Date @getResponseHeader \Last-Modified
        if last-modified > last-update
          last-update := last-modified

          old-thread = board.thread

          thread = parser.api JSON.parse @response

          new-posts = thread.replies.filter -> not old-thread.reply[it.no]
          deleted = old-thread.replies.filter -> not thread.reply[it.no]

          handle-new-posts thread, new-posts, deleted

          # swap out old thread state with new
          board.thread = thread

          reset-delay!
        else # no new posts
          increase-delay!

        restart-countdown!

    &ontimeout = !->
      updater.status.textContent = "request timed out..."
      restart-countdown!

    &onerror = !->
      updater.status.textContent = "Couldn't fetch thread page!"
      disable-updater!

    &onloadend = !->
      updater.button.disabled = false

    &send!

updater <<<
  tminus: delays[current-delay]
  countdown: repeat 1000ms {-start} !->
    updater.status.textContent = "Updating in #{updater.tminus} seconds..."

    if --updater.tminus < 0
      @stop!
      updater.update!

fade = !(post) ->
  # running immediately seems to break CSS yellow fade.
   defer 100ms !->
    post.classList.remove \new
    --unread
    draw-favicon board.favicon, if unread > 0 then "#unread" else ''

fade-when-visible = !->
  post = $ "p#{it.no}"

  y = post.offsetTop

  if (window.innerHeight + window.scrollY) > y
    if document.hidden
      # fade them once the tab is visible again
      listen document .once \visibilitychange !-> fade post
    else
      # now
      fade post
  else
    # wait until scrolled to
    window.addEventListener \scroll function reset
      if ( window.innerHeight + window.scrollY ) > post.offsetTop
        fade post
        window.removeEventListener \scroll reset

onready !->
  updater.status = $ \update-status
  updater.button = $ \update-now

  # autoupdate threads
  if board.isThread and not board.thread.closed
    updater.countdown.start!
    listen $ \update-now .click !->
      updater
        &countdown.stop!
        &tminus = delays[current-delay]
        &update!
  else
    $ \updater .hidden = true

