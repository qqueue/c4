# TODO handle new post highlighting better
# with CSS, and title changing
# look into including that fancy icon number libary
# or because it's not invented here, rewriting it
updater.update = ->
	clearTimeout timeout # clear any other running countdowns
	updater.status = "Updating thread..."
	updater.button.disabled = true
	with new XMLHttpRequest
		@open \get document.URL 
		# shit is weird, if the request is 200 OK, it'll time out every time
		# until it becomes 304 not modified, which will go through fine,
		# and trip the last_modified check
		# back to stupid workaround until this is fixed
		# @responseType = \document
		# FIXME the timeout is here because using responseType document
		# seems to never complete on some requests in firefox, even though firebug reports
		# that the request went 200 OK. not sure why, report bug maybe?
		listen this 
			.on \load ->
				# have to check the header instead of the status as 304,
				# becuase if the browser caches the request (shows up in firebug as
				# 304), it'll still be show up as 200 OK in here to prevent history
				# leaking. This is a slightly better solution than 4chanX, which adds a
				# cache-busting parameter to the URL, forcing a full server response
				# every time (which along with if-modified-since, allows them to test
				# for a real 304 response).
				last_modified = new Date( @getResponseHeader \Last-Modified ).getTime!
				if last_modified > parser.last_parse
					updater.status = "update detected, parsing"

					# html5... ;_;
					# can't use createHTMLDocument because all relative links
					# have a blank pathname, which screws up the detection of
					# crossthread links
					# TODO work around this better
					# html = document.implementation.createHTMLDocument ''
					html = document.createElement \div
					html.innerHTML = @response

					{thread} = parser.yotsuba html
					if thread.new.length > 0
						document.querySelector '#thread-' + thread.id + ' .replies'
							.insertAdjacentHTML do
								\beforeend
								render_all thread.new, \article, 'new reply'
						# refresh backlinks
						# TODO refactor out all the various places backlinks are made
						# into something less coupled
						for backlinks of document.querySelectorAll '.thread .backlinks'
							backlinks.insertAdjacentHTML do
								\beforeend
								Post[backlinks.parentNode.id.split \- .pop!].backlinks true

						# update title
						titler.number += thread.new.length

						# add scroll handler to rest number and new posts
						# when the window scrolls past the end of them
						resetNew thread.new


						# call after_update hooks
						fn thread.new for fn of callbacks

						updater.status = "Updated #{thread.new.length} new posts!"
				else
					updater.status = "No new posts..."
				updater.countdown!
			.on \timeout ->
				updater.status = "request timed out..."
				updater.countdown!
			.on \error ->
				updater.status = if @status is 404
					"thread 404'd"
				else
					"Couldn't fetch thread page!"
				# TODO redirect to archive
			.on \loadend ->
				updater.button.disabled = false
		@send!

# some spaghetti to remove the new class from posts
# once they are visible to the user
resetNew = (posts) ->
	posts.forEach (post) ->
		post = document.getElementById post.id
		y = post.offsetTop
		if ( window.innerHeight + window.scrollY ) > y
			if document.mozVisibilityState is \hidden or document.webkitVisibilityState is \hidden
				# fade them once the window is focused again
				listen window .on \focus function fadeNew
					setTimeout removeNewClass, 1000
					listen window .off fadeNew
			else # fade immediately
				post.classList.remove \new
				titler.number--
		else # wait till post is scrolled to
			listen window .on \scroll function reset
				if ( window.innerHeight + window.scrollY ) > y
					post.classList.remove \new
					titler.number--
					listen window .off \scroll reset


callbacks = []

updater.after_update = -> callbacks.push it

timeout = null

Object.defineProperty updater, \status,
	get: -> document.getElementById \update-status .textContent
	set: -> document.getElementById \update-status .textContent = it
Object.defineProperty updater, \count,
	get: -> document.getElementById \countdown .textContent
	set: -> document.getElementById \countdown .textContent = it
Object.defineProperty updater, \button,
	get: -> document.getElementById \update-now

updater.countdown = ->
	tminus = 30sec
	timeout := setTimeout do
		function tick
			updater.count = "Updating in #tminus seconds..."
			tminus--
			timeout := setTimeout tick, 1000ms
			if tminus is 0
				updater.update!
		1000ms


