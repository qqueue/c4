stylus     = require \stylus
{cjsify}   = require \commonjs-everywhere
lodash     = require \lodash
md5        = require \MD5

flatten = -> Array::concat.apply [], it # shallow flatten
join = -> flatten @@ .join \\n

# sexy (arguably) AOP/traditional-style time metrics
time = let names = {}, last = {}
  of: (it, pad = it.length) -> "#{it + ' ' * (pad - it.length)} : #{names[it] or 0}ms"
  end: !->
    if @@length > 1
      pad = Math.max.apply Math, (for @@ => &length)
      for @@
        time.stop &; say @of &, pad
    else
      time.stop it; say @of it
  start: !->
    names[it] ?= 0
    last[it] = Date.now!
  stop: !->
    if last[it]
      names[it] += Date.now! - last[it]
      delete last[it]
  as: (name, fn) -> ->
    time.start name
    ret = fn ...
    time.stop name
    ret
  restart-all: !-> names := {}

# for watch task, keep the AST of files not changed in memory for faster
# recompilation.
ast-cache = {}

# map from filename to md5sum, to determine if files really changed
contents-hash = {}

# flag whether something changed during compilation at all
# XXX kinda gross global state, oh well
var changed

nib = time.as 'Stylus compilation' (it, filename) ->
  stylus it, {filename, paths: ["#{__dirname}/style"]} .use require(\nib)! .render!

compile-coco = time.as 'Coco compilation' require(\coco)~compile
parse-js = time.as 'Reparse JS' require(\esprima)~parse
nephrite = time.as 'Nephrite compilation' require(\nephrite)

# if file hasn't actually changed from last compilation (by hash), use cached
# compiled AST. Unfortunately the hash check has to be done for every required
# file since cjsify will run `readFile` on every required file. It'd be better
# if we could skip the hash check for all but the file `fs.watch` tells us has
# changed, but hashing is pretty fast anyway.
cached-compilation = (compile) ->
  (it, filename) ->
    hash = md5 it

    if hash is not contents-hash[filename]
      # invalidate
      delete ast-cache[filename]
      # invalidate entire last compilation
      changed := true

    contents-hash[filename] = hash

    ast-cache[filename] ?= parse-js compile it, filename

coco-to-js = cached-compilation (it, filename) ->
  compile-coco it.toString!, {+bare, filename}

cojade = cached-compilation (it, filename) ->
  src = nephrite it.toString!, filename
  src = compile-coco src, {+bare, filename}

stylus-to-module = cached-compilation (it, filename) ->
  "module.exports = '#{nib it.toString!, filename
                         .replace /'/g "\/'" .replace /\n/g '\\n'}'"

ast-to-js = time.as 'AST->JS' require(\escodegen)~generate

outfile = \c4.user.js

task \build 'build userscript' ->
  try
    changed := false

    time.restart-all!

    time.start "Total build time"

    metadata = slurp \metadata.txt

    time.start "Commonjsification"

    ast = cjsify \src/c4.co __dirname,
      export: \c4
      handlers:
        \.co     : coco-to-js
        \.cojade : cojade
        \.styl   : stylus-to-module

    time.stop "Commonjsification"

    if changed
      # TODO something with sourcemap, when fire(fox|bug) gets support
      gen = ast-to-js ast

      spit do
        outfile
        join do
          metadata
          "(function(){"
          '"use strict";'
          # XXX hack to invalidate cached data in html5 storage when code changes
          "var c4_COMPILATION_VERSION = #{Math.random!};"
          gen
          "}).call(this)"

      say "#{new Date}: compiled script to #{outfile}"
    else
      say "#{new Date}: no actual changes detected."

    time.end do
      "Commonjsification"
      "Reparse JS"
      "Coco compilation"
      "Nephrite compilation"
      "Stylus compilation"
      "AST->JS"
      "Total build time"
  catch
    console.error e
    console.error e.stack

const times = 50 # XXX figure out Cokefile's batty options parsing

task \profile 'build project over and over for profile tick collection' !->
  say "Running build #times times..."
  for i til times
    say "run #i"
    invoke \build

# lodash, but with superior arguments order
debounce = (wait, fn) -> lodash.debounce fn, wait

task \watch 'watch for changes and rebuild automatically' ->
  invoke \build
  for <[style src templates src/features src/parser src/utils]>
    fs.watch &, interval: 1000, debounce 1000 !(event, filename) ->
      say "#event event detected on #filename. rebuilding..."
      invoke \build

