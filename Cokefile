fs     = require \fs
coco   = require \coco
stylus = require \stylus
jade   = require \jade

ls = -> "#it/#file" for file of fs.readdirSync it

flatten = -> Array::concat.apply [], it # shallow flatten

join = -> flatten @@ .join \\n
read = -> fs.readFileSync it, \utf8

compile = (it, options) ->
  try
    coco.compile do
      read it
      options
  catch
    throw new Error "Compiling #it:\n\t#{e.message}"

wrap = -> "let\n  #{read it .replace /\n/g '\n  '}"

compile-css = (cb) ->
  # ordering of files matters
  files = <[base page post postform thread yotsuba-colors youtube]>
  source = (for files => read "style/#&.styl")join \\n
  nib source .render cb

# stuff each file into a `let` IEFE, and then compile, which
# avoids coco's redefinition of boilerplate
compile-all = (css, paths) ->
  source = []
  for path of paths
    if fs.existsSync "src/#path/"
      # directory
      for ls "src/#path"
        compile & # detect compile errors
        source.push wrap &
    else
      # single file
      compile "src/#path.co"
      source.push wrap "src/#path.co"
  try
    coco.compile do
      source
        .join \\n
        .replace /%hakase\.css%/ css
      {+bare} # IEFE is added later
  catch
    throw new Error "Compiling all:\n\t#{e.message}"

compile-templates = ->
  source = ["var templates = {};"]
  try
    for filename of ls \templates
      #templates/do-it.jade => doIt
      name = filename.slice(10 -5)replace /-(.)/g -> it.1.toUpperCase!
      source.push "templates.#name = #{jade.compile read(filename), {+client, -compileDebug, filename}}"
  catch
    throw new Error "Jade error on #filename : #{e.message}"

  source * \\n

nib = -> stylus it .use require(\nib)!

outfile = \html5chan.user.js
metadata = read \metadata.txt

task \build 'build userscript' ->
  err, css <- compile-css
  try
    throw err if err
    fs.writeFileSync do
      outfile
      join do
        metadata
        "(function(){
        var" #avoid jade creating global
        read \node_modules/jade/runtime.min.js
        "jade.escape = function (it) { return it; };"
        compile-templates!
        compile-all css, <[
          intro
          utils
          classes
          parser
          enhancer
          updater
          poster
          onready
          features
          outro]>
        "}).call(this)"
    console.log "compiled script to #{outfile}"
  catch
    console.error e.message

debounce = (delay, fn) ->
  var timeout
  !->
    ctx = this
    args = arguments
    clearTimeout timeout
    timeout := setTimeout do
      !-> fn.apply ctx, args
      delay

task \watch 'watch for changes and rebuild automatically' ->
  invoke \build
  for it of <[style src templates src/features src/classes src/utils]>
    fs.watch it, interval: 1000, debounce 1000 (event, filename) ->
      console.log "#event event detected on #filename. rebuilding..."
      invoke \build

